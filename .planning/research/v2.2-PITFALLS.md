# Domain Pitfalls: v2.2 Drag-and-Drop Tables with Realtime Sync

**Domain:** Vue 3 drag-and-drop tables with Supabase Realtime
**Milestone:** v2.2 Polish & Bug Fixes
**Researched:** 2026-02-03
**Confidence:** HIGH (multiple authoritative sources cross-referenced)

---

## Critical Pitfalls

Mistakes that cause rewrites or major issues.

---

### Pitfall 1: Dual Source of Truth (SortableJS vs Vue Reactivity)

**What goes wrong:** SortableJS directly manipulates the DOM to show drag operations, while Vue expects to be the sole controller of DOM state through its reactivity system. This creates two competing sources of truth.

**Why it happens:** SortableJS was designed before modern reactive frameworks. It needs full DOM control for smooth drag animations. Vue's reactivity system also expects to control DOM updates based on reactive state changes.

**Consequences:**
- Array order in Pinia store doesn't match visual DOM order after drag
- Items "snap back" to original positions after drop
- Ghost elements remain visible after drop
- Computed properties derived from the array show stale data

**Warning signs:**
- `onEnd` event fires but visual order doesn't match array order
- Items visually reorder during drag but revert on drop
- DevTools shows correct array order but DOM shows different order

**Prevention:**

```typescript
// WRONG: Letting SortableJS handle array mutation
const onEnd = (evt: SortableEvent) => {
  // Array was already mutated by SortableJS - but Vue didn't see it!
  saveToDatabase(items.value)  // Saves wrong order
}

// CORRECT: Manual array manipulation with nextTick
import { nextTick } from 'vue'

const moveItemInArray = <T>(array: T[], from: number, to: number) => {
  const item = array.splice(from, 1)[0]
  nextTick(() => array.splice(to, 0, item))
}

const onEnd = (evt: SortableEvent) => {
  const { oldIndex, newIndex } = evt
  if (oldIndex !== undefined && newIndex !== undefined) {
    moveItemInArray(queueStore.requests, oldIndex, newIndex)
    saveToDatabase(queueStore.requests)
  }
}
```

**Detection:** Add a watcher that logs array order vs DOM order after each drag operation during development.

**Source:** [VueUse useSortable Issue #3727](https://github.com/vueuse/vueuse/issues/3727)

---

### Pitfall 2: Realtime Update During Active Drag Operation

**What goes wrong:** A Supabase Realtime event arrives while user is mid-drag. The store updates, Vue re-renders the list, and the drag operation breaks or produces unexpected results.

**Why it happens:** Realtime updates are asynchronous and can arrive at any time. The drag operation holds references to DOM elements that may be invalidated by a re-render.

**Consequences:**
- Dragged item disappears mid-drag
- Item drops in wrong position (positions shifted during drag)
- Drag handle becomes detached from item
- Race condition between optimistic update and realtime sync

**Warning signs:**
- Sporadic "jumpy" behavior during drag on busy queues
- Items occasionally drop in wrong position
- Console errors about accessing detached DOM nodes

**Prevention:**

```typescript
// Implement drag-aware realtime handling
const isDragging = ref(false)
const pendingUpdates = ref<RealtimePayload[]>([])

// In SortableJS config
const sortableOptions = {
  onStart: () => {
    isDragging.value = true
  },
  onEnd: (evt: SortableEvent) => {
    isDragging.value = false
    // Process any updates that arrived during drag
    processPendingUpdates()
    // Then handle the drag result
    handleDragEnd(evt)
  }
}

// In realtime subscription
const handleRealtimeUpdate = (payload: RealtimePayload) => {
  if (isDragging.value) {
    // Queue updates for processing after drag completes
    pendingUpdates.value.push(payload)
    return
  }
  // Normal processing
  applyUpdate(payload)
}

const processPendingUpdates = () => {
  // Apply queued updates, but skip if they conflict with drag result
  for (const update of pendingUpdates.value) {
    // Smart merge: don't overwrite positions we just set
    applyUpdateWithConflictResolution(update)
  }
  pendingUpdates.value = []
}
```

**Detection:** Log realtime events with `isDragging` state. Review logs after drag operations to see if updates arrived mid-drag.

---

### Pitfall 3: Optimistic Update Conflict with Realtime Echo

**What goes wrong:** User reorders queue (optimistic update shows immediately), then the same change echoes back via Supabase Realtime, causing a double-update or flicker.

**Why it happens:** Supabase Realtime broadcasts all changes to all subscribers, including the client that made the change. Without deduplication, the change is applied twice.

**Consequences:**
- Visual "flicker" as item moves, then moves again
- If timing is wrong, array mutations can corrupt order
- Wasted re-renders and potential performance issues

**Warning signs:**
- Items briefly flicker after drag operations
- DevTools shows same update applied twice
- Array watchers fire twice for single user action

**Prevention:**

```typescript
// Track pending operations to deduplicate realtime echoes
const pendingOperations = new Map<string, {
  type: 'reorder' | 'update',
  timestamp: number,
  expectedState: any
}>()

const reorderQueue = async (gateId: string, requestIds: string[]) => {
  const operationId = `reorder-${gateId}-${Date.now()}`

  // Mark operation as pending
  pendingOperations.set(operationId, {
    type: 'reorder',
    timestamp: Date.now(),
    expectedState: requestIds
  })

  // Optimistic update
  applyReorderLocally(gateId, requestIds)

  try {
    await client.rpc('reorder_queue', { p_gate_id: gateId, p_request_ids: requestIds })
  } catch (error) {
    // Rollback on failure
    pendingOperations.delete(operationId)
    await refresh()  // Fetch true state from server
    throw error
  }

  // Clean up after a delay (realtime echo should arrive within 1-2s)
  setTimeout(() => pendingOperations.delete(operationId), 3000)
}

// In realtime handler
const handleRealtimeUpdate = (payload: RealtimePayload) => {
  // Check if this is an echo of our own operation
  if (isEchoOfPendingOperation(payload)) {
    return  // Skip - we already applied this optimistically
  }
  applyUpdate(payload)
}

const isEchoOfPendingOperation = (payload: RealtimePayload): boolean => {
  // Check if payload matches any pending operation's expected outcome
  for (const [id, op] of pendingOperations) {
    if (payloadMatchesExpectedState(payload, op.expectedState)) {
      return true
    }
  }
  return false
}
```

**Detection:** Add logging to realtime handler showing whether updates were applied or skipped as echoes.

**Source:** [Supabase Discussion #1753](https://github.com/orgs/supabase/discussions/1753), [Building Scalable Real-Time Systems](https://medium.com/@ansh91627/building-scalable-real-time-systems-a-deep-dive-into-supabase-realtime-architecture-and-eccb01852f2b)

---

## Moderate Pitfalls

Mistakes that cause delays or technical debt.

---

### Pitfall 4: Missing Keyboard Alternative for Drag-and-Drop

**What goes wrong:** Users who cannot use a mouse/touch (mobility impairments, screen reader users) cannot reorder the queue.

**Why it happens:** SortableJS provides excellent mouse/touch drag, but keyboard support is often overlooked.

**Consequences:**
- WCAG 2.2 Level AA violation (Success Criterion 2.5.7)
- Excluded users cannot perform critical task
- Potential legal/compliance issues

**Warning signs:**
- No visible keyboard focus on draggable rows
- Tab key skips over drag handles
- No arrow key navigation for reordering

**Prevention:**

```vue
<template>
  <TableRow
    v-for="(item, index) in items"
    :key="item.id"
    tabindex="0"
    @keydown="handleKeyDown($event, index)"
  >
    <!-- Drag handle with aria label -->
    <TableCell>
      <button
        class="drag-handle"
        aria-label="Reorder item. Use arrow keys to move."
        @keydown.up.prevent="moveUp(index)"
        @keydown.down.prevent="moveDown(index)"
      >
        <GripVertical class="h-4 w-4" />
      </button>
    </TableCell>
    <!-- ... rest of row -->
  </TableRow>
</template>

<script setup>
const moveUp = (index: number) => {
  if (index > 0) {
    moveItemInArray(items.value, index, index - 1)
    saveReorder()
    // Move focus to the item (now at index - 1)
    nextTick(() => focusRow(index - 1))
  }
}

const moveDown = (index: number) => {
  if (index < items.value.length - 1) {
    moveItemInArray(items.value, index, index + 1)
    saveReorder()
    nextTick(() => focusRow(index + 1))
  }
}
</script>
```

**Source:** [WCAG 2.2 Understanding 2.5.7](https://www.w3.org/WAI/WCAG22/Understanding/dragging-movements.html), [TPGi Accessible Drag and Drop](https://www.tpgi.com/the-road-to-accessible-drag-and-drop-part-1/)

---

### Pitfall 5: Touch Drag Conflicts with Page Scroll (Mobile)

**What goes wrong:** On mobile devices, attempting to drag a table row instead scrolls the page, or vice versa.

**Why it happens:** Touch events on mobile can be interpreted as either scroll gestures or drag gestures. Without proper handling, the browser defaults to scroll.

**Consequences:**
- Mobile users cannot reorder queue
- Attempting to scroll accidentally moves items
- Frustrating UX requiring multiple attempts

**Warning signs:**
- Works on desktop, broken on mobile
- Page scrolls when trying to drag
- Items move when trying to scroll

**Prevention:**

```typescript
// 1. Use a dedicated drag handle (don't make entire row draggable)
const sortableOptions = {
  handle: '.drag-handle',  // Only drag via handle
  touchStartThreshold: 5,  // Require 5px movement to start drag
  delay: 150,              // 150ms hold before drag starts
  delayOnTouchOnly: true,  // Delay only applies to touch
}

// 2. Prevent scroll during drag
const onStart = (evt: SortableEvent) => {
  document.body.style.overflow = 'hidden'
  document.body.style.touchAction = 'none'
}

const onEnd = (evt: SortableEvent) => {
  document.body.style.overflow = ''
  document.body.style.touchAction = ''
}
```

```css
/* 3. CSS for drag handle */
.drag-handle {
  touch-action: none;  /* Prevent scroll interpretation */
  cursor: grab;
}

.drag-handle:active {
  cursor: grabbing;
}

/* Ensure adequate touch target size (WCAG 2.5.5) */
.drag-handle {
  min-width: 44px;
  min-height: 44px;
  display: flex;
  align-items: center;
  justify-content: center;
}
```

**Source:** [Dragula Issue #487](https://github.com/bevacqua/dragula/issues/487), [Medium Touch Scroll Prevention](https://medium.com/@yev-/how-to-prevent-scroll-touch-move-on-mobile-web-parent-elements-while-allowing-it-on-children-f7acb793c621)

---

### Pitfall 6: Missing Visual Feedback During Drag

**What goes wrong:** Users drag an item but get no visual feedback about where it will drop, leading to drops in wrong positions.

**Why it happens:** Default browser drag feedback is minimal. Custom styling is needed for good UX.

**Consequences:**
- Users drop items in wrong positions
- Uncertainty about whether drag is "working"
- Multiple correction attempts

**Warning signs:**
- Users frequently reorder multiple times
- Support questions about "drag not working"
- Slow task completion times

**Prevention:**

```css
/* Ghost element (the dragged item) */
.sortable-ghost {
  opacity: 0.4;
  background-color: hsl(var(--primary) / 0.1);
}

/* Chosen element (original position placeholder) */
.sortable-chosen {
  background-color: hsl(var(--muted));
}

/* Drop indicator line */
.sortable-drag {
  opacity: 1;
  box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
}

/* Animate other items moving out of the way */
.sortable-fallback {
  transition: transform 100ms ease;
}
```

```typescript
const sortableOptions = {
  ghostClass: 'sortable-ghost',
  chosenClass: 'sortable-chosen',
  dragClass: 'sortable-drag',
  animation: 150,  // Smooth animation for items moving
  easing: 'cubic-bezier(0.25, 1, 0.5, 1)',
}
```

**Source:** [Smart Interface Design Patterns](https://smart-interface-design-patterns.com/articles/drag-and-drop-ux/), [NN/g Drag and Drop](https://www.nngroup.com/articles/drag-drop/)

---

### Pitfall 7: Direct Pinia Store Mutation from SortableJS

**What goes wrong:** SortableJS callbacks directly mutate the Pinia store array, bypassing actions and making changes hard to trace.

**Why it happens:** It's convenient to pass `items.value` directly to SortableJS and let it mutate the array.

**Consequences:**
- Vue DevTools doesn't show the mutation
- No centralized place for business logic (validation, API calls)
- Harder to implement undo/redo
- Time-travel debugging doesn't work

**Warning signs:**
- Store changes appear without corresponding action calls in DevTools
- Business logic scattered across components
- Difficult to add validation or side effects to reorder

**Prevention:**

```typescript
// In store (queue.ts)
export const useQueueStore = defineStore('queue', () => {
  const requests = ref<PickupRequest[]>([])

  // Action for reordering - traceable in DevTools
  function reorderRequests(gateId: string, fromIndex: number, toIndex: number) {
    const gateRequests = requests.value.filter(r => r.assigned_gate_id === gateId)
    const item = gateRequests.splice(fromIndex, 1)[0]
    gateRequests.splice(toIndex, 0, item)

    // Update queue positions
    gateRequests.forEach((req, idx) => {
      const storeIdx = requests.value.findIndex(r => r.id === req.id)
      if (storeIdx !== -1) {
        requests.value[storeIdx].queue_position = idx + 1
      }
    })
  }

  return { requests, reorderRequests }
})

// In component - don't let SortableJS mutate store directly
const localItems = ref<PickupRequest[]>([])

// Sync from store (one-way)
watch(() => queueStore.gateRequests(gateId), (newVal) => {
  if (!isDragging.value) {
    localItems.value = [...newVal]
  }
}, { immediate: true })

// SortableJS uses localItems, not store
const sortableOptions = {
  onEnd: (evt) => {
    // Update store through action
    queueStore.reorderRequests(gateId, evt.oldIndex!, evt.newIndex!)
    // Then sync to server
    saveReorderToServer()
  }
}
```

**Source:** [Pinia State Documentation](https://pinia.vuejs.org/core-concepts/state.html), [Pinia Discussion #1264](https://github.com/vuejs/pinia/discussions/1264)

---

## Minor Pitfalls

Mistakes that cause annoyance but are fixable.

---

### Pitfall 8: Badge Count Flicker on Tab Switch

**What goes wrong:** Badge counts in tabs briefly show wrong numbers when switching tabs or during realtime updates.

**Why it happens:** Computed properties recalculate synchronously, but DOM updates batch. If counts change during render, badges can show intermediate states.

**Prevention:**

```typescript
// Use a debounced count for badge display
const rawProcessingCount = computed(() =>
  queueStore.requests.filter(r => r.status === 'processing').length
)

// Debounce to prevent flicker during rapid updates
const processingCount = refDebounced(rawProcessingCount, 100)
```

```vue
<TabsTrigger value="processing">
  Processing
  <Badge v-if="processingCount > 0" variant="secondary" class="ml-2">
    {{ processingCount }}
  </Badge>
</TabsTrigger>
```

---

### Pitfall 9: Drag Handle Not Visible Enough

**What goes wrong:** Users don't realize rows are draggable because the drag handle is too subtle.

**Prevention:**

```vue
<template>
  <TableCell class="w-10">
    <button
      class="drag-handle opacity-40 hover:opacity-100 transition-opacity"
      aria-label="Drag to reorder"
    >
      <GripVertical class="h-4 w-4" />
    </button>
  </TableCell>
</template>

<style>
/* Show handle more prominently on row hover */
tr:hover .drag-handle {
  opacity: 100;
}

/* Cursor feedback */
.drag-handle {
  cursor: grab;
}

.drag-handle:active {
  cursor: grabbing;
}
</style>
```

---

### Pitfall 10: No Loading State During Reorder Save

**What goes wrong:** User reorders, then reorders again before first save completes, creating race conditions.

**Prevention:**

```typescript
const isSaving = ref(false)

const sortableOptions = computed(() => ({
  disabled: isSaving.value,  // Disable drag during save
  // ... other options
}))

const handleReorderEnd = async (evt: SortableEvent) => {
  isSaving.value = true
  try {
    await queueActions.reorderQueue(gateId, getRequestIds())
  } finally {
    isSaving.value = false
  }
}
```

```vue
<template>
  <div :class="{ 'opacity-50 pointer-events-none': isSaving }">
    <!-- Table content -->
  </div>
  <div v-if="isSaving" class="absolute inset-0 flex items-center justify-center">
    <Loader2 class="h-6 w-6 animate-spin" />
  </div>
</template>
```

---

## Phase-Specific Warnings

| Phase Topic | Likely Pitfall | Mitigation |
|-------------|---------------|------------|
| SortableJS setup | Dual source of truth (#1) | Use manual array manipulation with nextTick |
| Realtime integration | Update during drag (#2) | Queue updates while dragging |
| Optimistic updates | Echo conflict (#3) | Track pending operations for deduplication |
| Accessibility | Missing keyboard alternative (#4) | Add arrow key handlers from the start |
| Mobile support | Touch/scroll conflict (#5) | Use drag handle with delay |
| UX polish | Missing visual feedback (#6) | Configure ghost/chosen CSS classes |
| State management | Direct mutation (#7) | Route changes through store actions |

---

## Integration with Existing useRealtimeQueue

The current `useRealtimeQueue.ts` composable needs modification for drag-aware handling:

```typescript
// Current code (lines 27-42) applies updates immediately
// Needs to be wrapped with drag-awareness

// Proposed modification pattern:
export function useRealtimeQueue() {
  // ... existing code ...

  // NEW: Drag state awareness
  const isDragging = ref(false)
  const pendingPayloads = ref<any[]>([])

  const setDragging = (dragging: boolean) => {
    isDragging.value = dragging
    if (!dragging) {
      // Process queued updates
      pendingPayloads.value.forEach(payload => processPayload(payload))
      pendingPayloads.value = []
    }
  }

  // Modify existing handler to check drag state
  const processPayload = (payload: any) => {
    if (isDragging.value) {
      pendingPayloads.value.push(payload)
      return
    }
    // existing processing logic
  }

  return {
    // ... existing returns ...
    setDragging,
    isDragging: readonly(isDragging),
  }
}
```

---

## Integration with Existing useQueueActions

The current `useQueueActions.ts` has `reorderQueue` (line 156-169) that needs optimistic update handling:

```typescript
// Current implementation (simplified):
async function reorderQueue(gateId: string, requestIds: string[]): Promise<boolean> {
  try {
    const { error } = await client.rpc('reorder_queue', {
      p_gate_id: gateId,
      p_request_ids: requestIds
    })
    if (error) throw error
    toast.success('Queue reordered')
    return true
  } catch (e) {
    toast.error('Failed to reorder queue')
    return false
  }
}

// Proposed with optimistic update:
async function reorderQueue(gateId: string, requestIds: string[]): Promise<boolean> {
  // 1. Optimistic update (immediate)
  const previousOrder = queueStore.getGateRequests(gateId).map(r => r.id)
  queueStore.applyReorder(gateId, requestIds)

  try {
    const { error } = await client.rpc('reorder_queue', {
      p_gate_id: gateId,
      p_request_ids: requestIds
    })
    if (error) throw error
    toast.success('Queue reordered')
    return true
  } catch (e) {
    // 2. Rollback on failure
    queueStore.applyReorder(gateId, previousOrder)
    toast.error('Failed to reorder queue')
    return false
  }
}
```

---

## Implementation Checklist

Before marking drag-and-drop complete:

- [ ] Array reorder uses manual splice + nextTick (not SortableJS mutation)
- [ ] Realtime updates queued during active drag operations
- [ ] Optimistic updates deduplicate realtime echoes
- [ ] Keyboard arrow keys move items up/down
- [ ] Drag handle has adequate touch target (44x44px)
- [ ] Touch delay prevents accidental drags while scrolling
- [ ] Ghost and placeholder elements styled clearly
- [ ] Store mutations go through actions (traceable in DevTools)
- [ ] Save-in-progress disables further drag operations
- [ ] Tested on actual iOS and Android devices

---

## Sources

### Authoritative (HIGH confidence)
- [VueUse useSortable Issue #3727](https://github.com/vueuse/vueuse/issues/3727) - Core reactivity issue documentation
- [WCAG 2.2 Understanding 2.5.7: Dragging Movements](https://www.w3.org/WAI/WCAG22/Understanding/dragging-movements.html) - Accessibility requirements
- [Pinia State Documentation](https://pinia.vuejs.org/core-concepts/state.html) - State management patterns

### Verified (MEDIUM confidence)
- [Building Scalable Real-Time Systems with Supabase](https://medium.com/@ansh91627/building-scalable-real-time-systems-a-deep-dive-into-supabase-realtime-architecture-and-eccb01852f2b) - Optimistic UI patterns
- [Smart Interface Design Patterns: Drag and Drop UX](https://smart-interface-design-patterns.com/articles/drag-and-drop-ux/) - Visual feedback best practices
- [TPGi: The Road to Accessible Drag and Drop](https://www.tpgi.com/the-road-to-accessible-drag-and-drop-part-1/) - Accessibility implementation
- [NN/g: Drag and Drop Design](https://www.nngroup.com/articles/drag-drop/) - UX guidelines

### Community (LOW confidence - verify before implementing)
- [Supabase Discussion #1753](https://github.com/orgs/supabase/discussions/1753) - Optimistic updates discussion
- [Dragula Issue #487](https://github.com/bevacqua/dragula/issues/487) - Mobile touch handling

---

*Pitfalls research for: Warehouse Pickup Queue v2.2 Polish & Bug Fixes*
*Focus: Drag-and-drop tables with realtime sync*
*Researched: 2026-02-03*
