---
phase: 11-processing-status-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260130200000_add_processing_status.sql
autonomous: true

must_haves:
  truths:
    - "Pickup requests can have status 'processing' in addition to existing statuses"
    - "Processing start timestamp is recorded when a pickup enters processing state"
    - "Only position 1 can start processing at a gate"
    - "Only one pickup can be processing per gate at a time"
    - "Reverting processing returns pickup to original queue position"
  artifacts:
    - path: "supabase/migrations/20260130200000_add_processing_status.sql"
      provides: "Schema changes and database functions for processing status"
      contains: "processing_started_at"
  key_links:
    - from: "start_processing function"
      to: "pickup_requests table"
      via: "atomic status transition"
      pattern: "SET status = 'processing'"
    - from: "revert_to_queue function"
      to: "pickup_requests table"
      via: "atomic status revert"
      pattern: "SET status = 'in_queue'"
---

<objective>
Add database support for the "processing" status to enable explicit pickup acceptance by gate operators.

Purpose: The processing status sits between "in_queue" and "completed" in the pickup lifecycle. It allows gate operators to explicitly accept a pickup (marking it as "processing") before completing it. This provides clear visibility into which pickups are actively being served.

Output: A migration file that adds the processing_started_at column, updates the status CHECK constraint to include 'processing', updates the partial index to include processing requests, and creates atomic database functions for start_processing and revert_to_queue operations.
</objective>

<execution_context>
@/Users/thomas/.claude/get-shit-done/workflows/execute-plan.md
@/Users/thomas/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-processing-status-foundation/11-CONTEXT.md
@.planning/phases/11-processing-status-foundation/11-RESEARCH.md
@supabase/migrations/20260128000002_create_pickup_requests_table.sql
@supabase/migrations/20260129000000_add_queue_functions.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create processing status migration</name>
  <files>supabase/migrations/20260130200000_add_processing_status.sql</files>
  <action>
Create a new migration file that:

1. **Add processing_started_at column:**
   ```sql
   ALTER TABLE pickup_requests
   ADD COLUMN processing_started_at timestamptz;

   COMMENT ON COLUMN pickup_requests.processing_started_at
   IS 'Timestamp when pickup entered processing state';
   ```

2. **Update status CHECK constraint** (must drop and recreate):
   ```sql
   ALTER TABLE pickup_requests
   DROP CONSTRAINT pickup_requests_status_check;

   ALTER TABLE pickup_requests
   ADD CONSTRAINT pickup_requests_status_check
   CHECK (status IN ('pending', 'approved', 'in_queue', 'processing', 'completed', 'cancelled'));
   ```

3. **Update partial index** to include processing requests (they retain queue_position for revert):
   ```sql
   DROP INDEX IF EXISTS idx_pickup_requests_queue;
   CREATE INDEX idx_pickup_requests_queue
       ON pickup_requests (assigned_gate_id, queue_position)
       WHERE status IN ('in_queue', 'processing');
   ```

4. **Create index for processing timestamp queries:**
   ```sql
   CREATE INDEX idx_pickup_requests_processing_started
       ON pickup_requests (processing_started_at)
       WHERE status = 'processing';
   ```

5. **Create start_processing function:**
   - Takes p_request_id uuid and p_gate_id uuid
   - Returns timestamptz (the processing_started_at value)
   - Verifies gate doesn't already have a processing request
   - Only allows position 1 to start processing
   - Atomically sets status='processing' and processing_started_at=now()
   - Raises exception if preconditions not met
   - Use SECURITY DEFINER pattern from existing queue functions
   - Grant execute to authenticated role

6. **Create revert_to_queue function:**
   - Takes p_request_id uuid
   - Returns integer (the preserved queue_position)
   - Sets status back to 'in_queue' and clears processing_started_at
   - Preserves original queue_position for fairness
   - Raises exception if request is not in processing status
   - Use SECURITY DEFINER pattern
   - Grant execute to authenticated role

Follow the existing migration patterns in the codebase. Use clear comments to explain each section.
  </action>
  <verify>
Run `supabase db reset` to apply migration. Then verify:
1. `\d pickup_requests` shows processing_started_at column
2. `\dC pickup_requests_status_check` shows 'processing' in allowed values
3. `\df start_processing` shows function exists
4. `\df revert_to_queue` shows function exists
5. `\df+ start_processing` shows SECURITY DEFINER
6. `SELECT has_function_privilege('authenticated', 'start_processing(uuid, uuid)', 'execute')` returns true
7. `SELECT has_function_privilege('authenticated', 'revert_to_queue(uuid)', 'execute')` returns true
  </verify>
  <done>
Migration applies cleanly. pickup_requests table has processing_started_at column. CHECK constraint allows 'processing' status. start_processing and revert_to_queue functions exist and are executable by authenticated role.
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify database functions work correctly</name>
  <files>supabase/migrations/20260130200000_add_processing_status.sql</files>
  <action>
Test the database functions by running SQL queries in psql or Supabase Studio:

1. **Test start_processing:**
   - Create a test pickup request in 'in_queue' status at position 1 for a gate
   - Call start_processing with the request id and gate id
   - Verify it returns a timestamp
   - Verify the request now has status='processing' and processing_started_at is set

2. **Test start_processing constraints:**
   - Try to start processing on a request that is not at position 1 - should fail
   - Try to start processing when gate already has a processing request - should fail
   - Try to start processing on a request not in 'in_queue' status - should fail

3. **Test revert_to_queue:**
   - Call revert_to_queue on the processing request
   - Verify it returns the original queue_position
   - Verify the request now has status='in_queue' and processing_started_at is NULL

4. **Test revert_to_queue constraints:**
   - Try to revert a request that is not in 'processing' status - should fail

If any test fails, fix the migration file and re-run `supabase db reset`.
  </action>
  <verify>
All test cases pass:
- start_processing succeeds for position 1 in_queue request
- start_processing fails for non-position-1 requests
- start_processing fails when gate already has processing request
- revert_to_queue succeeds for processing request
- revert_to_queue fails for non-processing request
  </verify>
  <done>
Database functions correctly enforce business rules: only position 1 can start processing, only one processing per gate, revert preserves original position.
  </done>
</task>

</tasks>

<verification>
1. Run `supabase db reset` - migration applies without errors
2. Query pickup_requests schema shows processing_started_at column
3. Insert a test request and manually test:
   - Add to queue at position 1
   - Call start_processing - succeeds, returns timestamp
   - Status is now 'processing', processing_started_at is set
   - Call revert_to_queue - succeeds, returns original position
   - Status is now 'in_queue', processing_started_at is NULL
4. Constraint tests pass (non-position-1 fails, duplicate processing fails)
</verification>

<success_criteria>
- Migration file exists at supabase/migrations/20260130200000_add_processing_status.sql
- Migration applies cleanly with `supabase db reset`
- pickup_requests.processing_started_at column exists
- CHECK constraint includes 'processing' status
- start_processing function works with position 1 constraint
- revert_to_queue function preserves original queue position
- Both functions reject invalid state transitions
</success_criteria>

<output>
After completion, create `.planning/phases/11-processing-status-foundation/11-01-SUMMARY.md`
</output>
