---
phase: 15-pinia-infrastructure
plan: 03
type: execute
wave: 3
depends_on: [15-02]
files_modified:
  - staff/app/composables/useRealtimeQueue.ts
  - staff/app/composables/useQueueActions.ts
  - staff/app/composables/useGateManagement.ts
autonomous: true

must_haves:
  truths:
    - "Realtime events update store state (not local refs)"
    - "Queue actions fetch data into stores"
    - "Composables use stores for shared state"
  artifacts:
    - path: "staff/app/composables/useRealtimeQueue.ts"
      provides: "Realtime subscriptions that update stores"
      contains: "useQueueStore"
    - path: "staff/app/composables/useQueueActions.ts"
      provides: "Queue RPC calls that update stores"
      contains: "useQueueStore"
    - path: "staff/app/composables/useGateManagement.ts"
      provides: "Gate CRUD that updates stores"
      contains: "useGatesStore"
  key_links:
    - from: "staff/app/composables/useRealtimeQueue.ts"
      to: "staff/app/stores/queue.ts"
      via: "useQueueStore()"
      pattern: "useQueueStore\\(\\)"
    - from: "staff/app/composables/useQueueActions.ts"
      to: "staff/app/stores/queue.ts"
      via: "useQueueStore()"
      pattern: "useQueueStore\\(\\)"
---

<objective>
Refactor composables to use Pinia stores for state management following the hybrid pattern.

Purpose: Composables handle side effects (realtime, RPC), stores hold shared state.
Output: Composables that fetch/mutate data and push results to stores.
</objective>

<execution_context>
@/Users/thomas/.claude/get-shit-done/workflows/execute-plan.md
@/Users/thomas/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-pinia-infrastructure/15-RESEARCH.md
@.planning/phases/15-pinia-infrastructure/15-02-SUMMARY.md

# Stores created in 15-02
@staff/app/stores/queue.ts
@staff/app/stores/gates.ts

# Current composables to refactor
@staff/app/composables/useRealtimeQueue.ts
@staff/app/composables/useQueueActions.ts
@staff/app/composables/useGateManagement.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor useQueueActions to use store</name>
  <files>staff/app/composables/useQueueActions.ts</files>
  <action>
Refactor `staff/app/composables/useQueueActions.ts` to:
1. Add fetchRequests() method that loads data into the queue store
2. Remove optimistic updates (let realtime handle state sync)
3. Keep all existing RPC/mutation methods (they work fine)
4. Add fetchGates() method that loads data into the gates store

Updated structure:

```typescript
import { ref, readonly } from 'vue'
import { toast } from 'vue-sonner'
import type { SupabaseClient } from '@supabase/supabase-js'
import { PICKUP_STATUS } from '#shared/types/pickup-request'
import type { PickupRequest } from '#shared/types/pickup-request'
import type { GateWithCount } from '#shared/types/gate'

export function useQueueActions() {
  const client = useSupabaseClient() as SupabaseClient
  const queueStore = useQueueStore()
  const gatesStore = useGatesStore()

  const pending = ref<Record<string, boolean>>({})

  // === Data Fetching ===
  async function fetchRequests(): Promise<void> {
    queueStore.loading = true
    try {
      const { data, error } = await client
        .from('pickup_requests')
        .select('id, sales_order_number, company_name, customer_email, status, email_flagged, assigned_gate_id, queue_position, is_priority, processing_started_at, created_at, gate:gates(id, gate_number)')
        .order('created_at', { ascending: false })

      if (error) throw error
      queueStore.setRequests(data as PickupRequest[])
    } finally {
      queueStore.loading = false
    }
  }

  async function fetchGates(): Promise<void> {
    gatesStore.loading = true
    try {
      const { data, error } = await client
        .from('gates')
        .select('id, gate_number, is_active')
        .order('gate_number')

      if (error) throw error

      // Get queue counts per gate
      const { data: counts } = await client
        .from('pickup_requests')
        .select('assigned_gate_id')
        .eq('status', PICKUP_STATUS.IN_QUEUE)

      const countMap: Record<string, number> = {}
      for (const row of counts ?? []) {
        const gateId = (row as { assigned_gate_id: string | null }).assigned_gate_id
        if (gateId) {
          countMap[gateId] = (countMap[gateId] || 0) + 1
        }
      }

      const gatesWithCount: GateWithCount[] = (data ?? []).map(g => ({
        ...g,
        queue_count: countMap[g.id] || 0
      }))

      gatesStore.setGates(gatesWithCount)
    } finally {
      gatesStore.loading = false
    }
  }

  // Refresh both stores
  async function refresh(): Promise<void> {
    await Promise.all([fetchRequests(), fetchGates()])
  }

  // === Queue Actions (keep existing implementations) ===
  // ... assignGate, cancelRequest, completeRequest, reorderQueue,
  // ... setPriority, clearPriority, moveToGate, startProcessing, revertToQueue
  // All remain unchanged - they perform mutations and realtime will sync state

  // ... (keep all existing action implementations)

  return {
    pending: readonly(pending),
    // Data fetching
    fetchRequests,
    fetchGates,
    refresh,
    // Actions (existing)
    assignGate,
    cancelRequest,
    completeRequest,
    reorderQueue,
    setPriority,
    clearPriority,
    moveToGate,
    startProcessing,
    revertToQueue
  }
}
```

Key changes:
- Add `fetchRequests()` that populates queueStore
- Add `fetchGates()` that populates gatesStore (extracted from index.vue)
- Add `refresh()` convenience method
- Remove optimistic updates from actions (realtime handles sync)
- Keep all existing action implementations unchanged
  </action>
  <verify>
Run `cat staff/app/composables/useQueueActions.ts` to verify changes.
Run `npx nuxi typecheck --cwd staff` to verify no type errors.
  </verify>
  <done>useQueueActions has fetchRequests(), fetchGates(), refresh() methods that populate stores.</done>
</task>

<task type="auto">
  <name>Task 2: Refactor useRealtimeQueue to update stores</name>
  <files>staff/app/composables/useRealtimeQueue.ts</files>
  <action>
Refactor `staff/app/composables/useRealtimeQueue.ts` to update stores instead of invoking a callback:

```typescript
import type { RealtimeChannel } from '@supabase/supabase-js'
import { useDocumentVisibility } from '@vueuse/core'
import { ref, readonly, watch, onUnmounted } from 'vue'
import type { PickupRequest } from '#shared/types/pickup-request'

export type SubscriptionStatus = 'connecting' | 'connected' | 'disconnected' | 'error'

export function useRealtimeQueue() {
  const client = useSupabaseClient()
  const visibility = useDocumentVisibility()
  const queueStore = useQueueStore()

  const status = ref<SubscriptionStatus>('connecting')
  let channel: RealtimeChannel | null = null

  // Callback for full refresh (used on reconnect)
  let refreshCallback: (() => void) | null = null

  const subscribe = (onRefresh?: () => void) => {
    // Store refresh callback for visibility change handling
    refreshCallback = onRefresh ?? null

    if (channel) return // Prevent duplicate subscriptions

    status.value = 'connecting'

    channel = client
      .channel('pickup-requests-staff')
      .on(
        'postgres_changes',
        { event: '*', schema: 'public', table: 'pickup_requests' },
        (payload) => {
          // Update store based on event type
          if (payload.eventType === 'INSERT') {
            queueStore.addRequest(payload.new as PickupRequest)
          } else if (payload.eventType === 'UPDATE') {
            queueStore.updateRequest(payload.new.id as string, payload.new as Partial<PickupRequest>)
          } else if (payload.eventType === 'DELETE') {
            queueStore.removeRequest(payload.old.id as string)
          }
        }
      )
      .on(
        'postgres_changes',
        { event: '*', schema: 'public', table: 'gates' },
        () => {
          // For gate changes, trigger a full refresh (simpler than tracking counts)
          refreshCallback?.()
        }
      )
      .subscribe((subscribeStatus) => {
        if (subscribeStatus === 'SUBSCRIBED') {
          status.value = 'connected'
        } else if (subscribeStatus === 'CLOSED' || subscribeStatus === 'TIMED_OUT') {
          status.value = 'disconnected'
        } else if (subscribeStatus === 'CHANNEL_ERROR') {
          status.value = 'error'
        }
      })
  }

  const unsubscribe = () => {
    if (channel) {
      client.removeChannel(channel)
      channel = null
    }
    status.value = 'disconnected'
    refreshCallback = null
  }

  // Auto-reconnect and refresh on tab visibility change
  watch(visibility, async (current, previous) => {
    if (current === 'visible' && previous === 'hidden') {
      // Refresh data (may have missed events while hidden)
      refreshCallback?.()
      // Reconnect if needed
      if (status.value !== 'connected') {
        unsubscribe()
        subscribe(refreshCallback ?? undefined)
      }
    }
  })

  // Cleanup on unmount
  onUnmounted(() => {
    unsubscribe()
  })

  return {
    status: readonly(status),
    subscribe,
    unsubscribe
  }
}
```

Key changes:
- Import and use queueStore to update state directly
- Handle INSERT/UPDATE/DELETE events with appropriate store actions
- Keep callback for full refresh (gate changes still need full refresh for queue counts)
- Subscribe to both pickup_requests AND gates tables
- Gate changes trigger full refresh (simpler than tracking counts)
  </action>
  <verify>
Run `cat staff/app/composables/useRealtimeQueue.ts` to verify changes.
Run `npx nuxi typecheck --cwd staff` to verify no type errors.
  </verify>
  <done>useRealtimeQueue updates store state on realtime events.</done>
</task>

<task type="auto">
  <name>Task 3: Refactor useGateManagement to use store</name>
  <files>staff/app/composables/useGateManagement.ts</files>
  <action>
Refactor `staff/app/composables/useGateManagement.ts` to use the gates store:

```typescript
import { ref, readonly } from 'vue'
import { toast } from 'vue-sonner'
import type { SupabaseClient } from '@supabase/supabase-js'
import { PICKUP_STATUS } from '#shared/types/pickup-request'

export function useGateManagement() {
  const client = useSupabaseClient() as SupabaseClient
  const gatesStore = useGatesStore()

  const pending = ref(false)

  async function createGate(gateNumber: number): Promise<string | null> {
    pending.value = true
    try {
      const { data, error } = await client
        .from('gates')
        .insert({ gate_number: gateNumber })
        .select('id, gate_number, is_active')
        .single()

      if (error) throw error

      // Add to store with queue_count of 0 (new gate has no queue)
      gatesStore.addGate({ ...data, queue_count: 0 })

      toast.success(`Gate ${gateNumber} created`)
      return data.id as string
    } catch (e: unknown) {
      const err = e as { code?: string }
      if (err.code === '23505') {
        toast.error(`Gate ${gateNumber} already exists`)
      } else {
        toast.error('Failed to create gate')
      }
      return null
    } finally {
      pending.value = false
    }
  }

  async function toggleGateActive(gateId: string, isActive: boolean): Promise<boolean> {
    pending.value = true
    try {
      // If disabling, check for customers in queue
      if (!isActive) {
        const { count } = await client
          .from('pickup_requests')
          .select('id', { count: 'exact', head: true })
          .eq('assigned_gate_id', gateId)
          .eq('status', PICKUP_STATUS.IN_QUEUE)

        if (count && count > 0) {
          toast.error('Cannot disable gate with customers in queue')
          return false
        }
      }

      const { error } = await client
        .from('gates')
        .update({ is_active: isActive })
        .eq('id', gateId)

      if (error) throw error

      // Update store
      gatesStore.updateGate(gateId, { is_active: isActive })

      toast.success(isActive ? 'Gate enabled' : 'Gate disabled')
      return true
    } catch (e) {
      toast.error(`Failed to ${isActive ? 'enable' : 'disable'} gate`)
      return false
    } finally {
      pending.value = false
    }
  }

  return {
    pending: readonly(pending),
    createGate,
    toggleGateActive,
  }
}
```

Key changes:
- Import and use gatesStore
- createGate adds new gate to store after successful creation
- toggleGateActive updates store after successful toggle
- Optimistic updates are safe here (we update after server confirms)
  </action>
  <verify>
Run `cat staff/app/composables/useGateManagement.ts` to verify changes.
Run `npx nuxi typecheck --cwd staff` to verify no type errors.
  </verify>
  <done>useGateManagement updates gatesStore on create and toggle operations.</done>
</task>

</tasks>

<verification>
1. All three composables import and use the appropriate stores
2. useQueueActions has fetchRequests() and fetchGates() methods
3. useRealtimeQueue handles INSERT/UPDATE/DELETE events via store actions
4. useGateManagement updates store after CRUD operations
5. `npx nuxi typecheck --cwd staff` passes with no errors
</verification>

<success_criteria>
- Composables use stores for state (not local refs for shared data)
- Realtime events update store state
- Data fetching methods populate stores
- Hybrid pattern: composables handle side effects, stores hold state
</success_criteria>

<output>
After completion, create `.planning/phases/15-pinia-infrastructure/15-03-SUMMARY.md`
</output>
