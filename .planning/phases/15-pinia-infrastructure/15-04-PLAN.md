---
phase: 15-pinia-infrastructure
plan: 04
type: execute
wave: 4
depends_on: [15-03]
files_modified:
  - staff/app/app.vue
  - staff/app/pages/index.vue
  - staff/app/pages/gate/[id].vue
autonomous: true

must_haves:
  truths:
    - "Pages read state from stores via storeToRefs"
    - "Realtime subscription is initialized at app level"
    - "No duplicate subscriptions after page navigation"
    - "UI updates when store state changes"
  artifacts:
    - path: "staff/app/app.vue"
      provides: "App-level subscription initialization"
      contains: "useRealtimeQueue"
    - path: "staff/app/pages/index.vue"
      provides: "Dashboard using store state"
      contains: "storeToRefs"
    - path: "staff/app/pages/gate/[id].vue"
      provides: "Gate page using store state"
      contains: "storeToRefs"
  key_links:
    - from: "staff/app/pages/index.vue"
      to: "staff/app/stores/queue.ts"
      via: "storeToRefs(useQueueStore())"
      pattern: "storeToRefs.*useQueueStore"
    - from: "staff/app/app.vue"
      to: "staff/app/composables/useRealtimeQueue.ts"
      via: "subscribe() in onMounted"
      pattern: "onMounted.*subscribe"
---

<objective>
Migrate pages to use Pinia stores and establish app-level subscription management.

Purpose: Complete the Pinia migration so UI components read from centralized stores.
Output: Pages that reactively display store state, with subscriptions managed at app level.
</objective>

<execution_context>
@/Users/thomas/.claude/get-shit-done/workflows/execute-plan.md
@/Users/thomas/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-pinia-infrastructure/15-RESEARCH.md
@.planning/phases/15-pinia-infrastructure/15-03-SUMMARY.md

# Stores and composables
@staff/app/stores/queue.ts
@staff/app/stores/gates.ts
@staff/app/composables/useQueueActions.ts
@staff/app/composables/useRealtimeQueue.ts

# Pages to migrate
@staff/app/app.vue
@staff/app/pages/index.vue
@staff/app/pages/gate/[id].vue
</context>

<tasks>

<task type="auto">
  <name>Task 1: Setup app-level subscription and data fetching</name>
  <files>staff/app/app.vue</files>
  <action>
Update `staff/app/app.vue` to initialize data fetching and realtime subscription at the app level:

```vue
<script setup lang="ts">
import { Toaster } from '@/components/ui/sonner'

const { fetchRequests, fetchGates, refresh } = useQueueActions()
const { subscribe, unsubscribe } = useRealtimeQueue()

// Fetch initial data and subscribe at app level
onMounted(async () => {
  // Fetch initial data
  await Promise.all([fetchRequests(), fetchGates()])
  // Subscribe to realtime updates, pass refresh for gate changes
  subscribe(refresh)
})

onUnmounted(() => {
  unsubscribe()
})
</script>

<template>
  <NuxtLayout>
    <NuxtPage />
  </NuxtLayout>
  <Toaster position="top-right" />
</template>
```

Key changes:
- Import and call useQueueActions for data fetching
- Import and call useRealtimeQueue for subscription
- Fetch data and subscribe in onMounted (once, at app level)
- Unsubscribe in onUnmounted
- Pass refresh callback for gate changes (full refresh needed for counts)

This prevents duplicate subscriptions when navigating between pages.
  </action>
  <verify>
Run `cat staff/app/app.vue` to verify changes.
Run `npx nuxi typecheck --cwd staff` to verify no type errors.
  </verify>
  <done>app.vue initializes data fetching and realtime subscription at app level.</done>
</task>

<task type="auto">
  <name>Task 2: Migrate index.vue to use stores</name>
  <files>staff/app/pages/index.vue</files>
  <action>
Refactor `staff/app/pages/index.vue` to use stores instead of useAsyncData:

Key changes:
1. Remove useAsyncData calls for requests and gates
2. Use storeToRefs to get reactive state from stores
3. Remove local subscribe/unsubscribe (handled at app level)
4. Keep computed properties that derive from store state
5. Keep all action handlers (they still call composable methods)

Replace the data fetching section:

```vue
<script setup lang="ts">
import { storeToRefs } from 'pinia'
// ... other imports

definePageMeta({
  middleware: 'auth'
})

// Use stores via storeToRefs for reactive state
const queueStore = useQueueStore()
const gatesStore = useGatesStore()
const { requests, loading: requestsLoading } = storeToRefs(queueStore)
const { gates: allGates, activeGates } = storeToRefs(gatesStore)

// Composables for actions
const { pending, assignGate, cancelRequest, completeRequest, reorderQueue, setPriority, clearPriority, moveToGate, startProcessing, revertToQueue, refresh } = useQueueActions()
const { createGate, toggleGateActive } = useGateManagement()
const { status: realtimeStatus } = useRealtimeQueue()

// NOTE: Realtime subscription is handled at app level (app.vue)
// No need for local subscribe/unsubscribe

// Show completed/cancelled toggle
const showCompleted = ref(false)

// Computed for active gates (from store getter)
const gates = activeGates

// ... rest of computed properties remain the same but use requests.value and gates.value
```

Important changes to computed properties:
- Use `requests.value` instead of `requests.value ?? []` (store initializes as [])
- Use `allGates.value` and `gates.value` (activeGates getter)
- Remove refreshRequests/refreshGates - use refresh() from composable instead

For action handlers that called `await refresh()`, they continue to work as-is since refresh() is now from the composable.

For the `refreshing` computed:
```typescript
const refreshing = computed(() => requestsLoading.value)
```

Remove:
- The `useAsyncData` calls for 'pickup-requests-list' and 'all-gates'
- The `onMounted/onUnmounted` subscription setup (moved to app.vue)
- The local `refresh` function definition (use composable's refresh)

Keep all template code unchanged - it still binds to the same reactive refs.
  </action>
  <verify>
Run `cat staff/app/pages/index.vue` to verify changes.
Run `npx nuxi typecheck --cwd staff` to verify no type errors.
  </verify>
  <done>index.vue reads from stores via storeToRefs, no local subscription management.</done>
</task>

<task type="auto">
  <name>Task 3: Migrate gate/[id].vue to use stores</name>
  <files>staff/app/pages/gate/[id].vue</files>
  <action>
Refactor `staff/app/pages/gate/[id].vue` to use stores:

Key changes:
1. Use storeToRefs to get queue state from store
2. Remove local fetch functions for queue data
3. Keep gate-specific fetching (gate info is route-specific)
4. Remove local subscription (handled at app level)
5. Derive queue data from store with computed properties

```vue
<script setup lang="ts">
import { storeToRefs } from 'pinia'
import { computed, ref, onMounted, watch } from 'vue'
// ... other imports

definePageMeta({
  middleware: 'auth'
})

const route = useRoute()
const client = useSupabaseClient()

// Store and composables
const queueStore = useQueueStore()
const { requests } = storeToRefs(queueStore)
const { pending, startProcessing, revertToQueue, completeRequest } = useQueueActions()
const { status: realtimeStatus } = useRealtimeQueue()

// Dialog state
const showCompleteDialog = ref(false)

// Gate ID from route
const gateId = computed(() => route.params.id as string)

// Gate info state (still fetched locally - gate-specific)
const gate = ref<{ id: string; gate_number: number; is_active: boolean } | null>(null)
const gateError = ref<Error | null>(null)
const gateLoading = ref(true)

// Fetch gate info (gate-specific, not from global store)
async function fetchGate() {
  gateLoading.value = true
  gateError.value = null

  const { data, error } = await client
    .from('gates')
    .select('id, gate_number, is_active')
    .eq('id', gateId.value)
    .single()

  if (error) {
    console.error('Gate fetch error:', error)
    gateError.value = error
  } else {
    gate.value = data
  }
  gateLoading.value = false
}

// Queue data derived from store (filtered by gate)
const queue = computed(() => {
  return requests.value
    .filter(r =>
      r.assigned_gate_id === gateId.value &&
      (r.status === PICKUP_STATUS.IN_QUEUE || r.status === PICKUP_STATUS.PROCESSING)
    )
    .sort((a, b) => (a.queue_position ?? 0) - (b.queue_position ?? 0))
})

// Current pickup: processing takes precedence, otherwise position 1
const currentPickup = computed(() => {
  if (queue.value.length === 0) return null

  const processing = queue.value.find(r => r.status === PICKUP_STATUS.PROCESSING)
  if (processing) return processing

  return queue.value.find(r => r.queue_position === 1) ?? queue.value[0]
})

// Next up: position 2 in queue
const nextUp = computed(() => {
  return queue.value.find(p => p.queue_position === 2 && p.status === PICKUP_STATUS.IN_QUEUE) ?? null
})

// Queue count: number of in_queue items (excludes processing)
const queueCount = computed(() => {
  return queue.value.filter(p => p.status === PICKUP_STATUS.IN_QUEUE).length
})

// Loading state
const loading = computed(() => gateLoading.value)

// Error states
const gateNotFound = computed(() => !gateLoading.value && gateError.value !== null)
const gateDisabled = computed(() => gate.value && !gate.value.is_active)

// Action pending state
const actionPending = computed(() => {
  return currentPickup.value ? pending.value[currentPickup.value.id] : false
})

// Action handlers remain the same but no need to call fetchQueue after
async function handleStartProcessing() {
  if (!currentPickup.value || !gate.value) return
  await startProcessing(currentPickup.value.id, gate.value.id)
  // No fetchQueue needed - realtime updates store
}

async function handleRevert() {
  if (!currentPickup.value) return
  await revertToQueue(currentPickup.value.id)
  // No fetchQueue needed - realtime updates store
}

async function handleComplete() {
  if (!currentPickup.value) return
  showCompleteDialog.value = false
  await completeRequest(currentPickup.value.id, gate.value?.id)
  // No fetchQueue needed - realtime updates store
}

// Only fetch gate info on mount (queue comes from store)
onMounted(async () => {
  await fetchGate()
})

// NOTE: Realtime subscription handled at app level (app.vue)
// No local subscribe/unsubscribe needed
</script>
```

Key changes:
- Queue data now comes from store (filtered by gateId)
- Gate info still fetched locally (route-specific, single gate)
- Remove fetchQueue() and local queue ref
- Remove subscription management (app-level)
- Action handlers no longer call fetchQueue after (realtime syncs)
- Computed properties filter store data for this gate

Template remains unchanged - same reactive bindings.
  </action>
  <verify>
Run `cat staff/app/pages/gate/[id].vue` to verify changes.
Run `npx nuxi typecheck --cwd staff` to verify no type errors.
  </verify>
  <done>gate/[id].vue derives queue data from store, filtered by gate ID.</done>
</task>

</tasks>

<verification>
1. app.vue initializes data and subscription at app level
2. index.vue uses storeToRefs for reactive store access
3. gate/[id].vue derives queue from store, filtered by gate ID
4. No page has local subscribe/unsubscribe (all at app level)
5. `npx nuxi typecheck --cwd staff` passes
6. Manual test: Navigate between pages, verify no duplicate subscriptions (check console)
</verification>

<success_criteria>
- Pages read from stores via storeToRefs
- Realtime subscription is app-level (single subscription)
- UI updates when store state changes
- No duplicate subscriptions on navigation
- Vue DevTools shows store state updates
</success_criteria>

<output>
After completion, create `.planning/phases/15-pinia-infrastructure/15-04-SUMMARY.md`
</output>
