---
phase: 06-staff-advanced-queue-operations
plan: 04
type: execute
wave: 3
depends_on: ["06-01", "06-02", "06-03"]
files_modified:
  - staff/app/pages/index.vue
  - staff/app/components/dashboard/columns.ts
autonomous: false

must_haves:
  truths:
    - "Staff can view per-gate queues in dedicated tabs"
    - "Staff can drag to reorder within a gate tab"
    - "Staff can access gate management panel"
    - "Reorder operations sync to database"
    - "Priority operations work from gate queue view"
    - "Gate CRUD operations work and refresh the UI"
  artifacts:
    - path: "staff/app/pages/index.vue"
      provides: "Dashboard with per-gate tabs, gate management tab, and integrated actions"
      min_lines: 200
  key_links:
    - from: "index.vue"
      to: "GateQueueList component"
      via: "component import and v-for rendering"
      pattern: "<GateQueueList"
    - from: "index.vue"
      to: "GateManagement component"
      via: "component in Manage Gates tab"
      pattern: "<GateManagement"
    - from: "index.vue"
      to: "useGateManagement composable"
      via: "composable import for CRUD handlers"
      pattern: "useGateManagement\\(\\)"
---

<objective>
Integrate all Phase 6 components into the dashboard: per-gate tabs with sortable queues, gate management panel, and wired actions.

Purpose: This is the final integration that makes all advanced queue operations accessible to staff through the existing dashboard interface.

Output: Updated dashboard page with gate-specific views, drag-and-drop reordering, and gate management capabilities.
</objective>

<execution_context>
@/Users/thomas/.claude/get-shit-done/workflows/execute-plan.md
@/Users/thomas/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-staff-advanced-queue-operations/06-CONTEXT.md
@.planning/phases/06-staff-advanced-queue-operations/06-RESEARCH.md

# Current implementation
@staff/app/pages/index.vue
@staff/app/components/dashboard/columns.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update dashboard with per-gate tabs and management</name>
  <files>staff/app/pages/index.vue</files>
  <action>
Restructure the dashboard tabs to include per-gate views and gate management:

**New Tab Structure:**
1. "All Requests" (existing Active Queue renamed) - DataTable with all requests
2. "History" (existing) - completed/cancelled requests
3. One tab per active gate: "Gate 1", "Gate 2", etc. - GateQueueList for that gate
4. "Manage Gates" - GateManagement panel

**Implementation changes:**

1. Import new components:
```typescript
import GateQueueList from '@/components/dashboard/GateQueueList.vue'
import GateManagement from '@/components/gates/GateManagement.vue'
import { useGateManagement } from '@/composables/useGateManagement'
```

2. Get gate management functions:
```typescript
const { createGate, renameGate, deleteGate, toggleGateActive } = useGateManagement()
```

3. Extend useQueueActions destructuring:
```typescript
const { pending, assignGate, cancelRequest, completeRequest, reorderQueue, setPriority, moveToGate } = useQueueActions()
```

4. Add computed for per-gate queue items:
```typescript
const gatesWithQueues = computed(() => {
  return (gates.value ?? []).map(gate => ({
    ...gate,
    queue: (requests.value ?? [])
      .filter(r => r.assigned_gate_id === gate.id && r.status === 'in_queue')
      .sort((a, b) => (a.queue_position ?? 0) - (b.queue_position ?? 0))
  }))
})
```

5. Add reorder handler with optimistic rollback:
```typescript
async function handleReorder(gateId: string, requestIds: string[]) {
  const success = await reorderQueue(gateId, requestIds)
  if (!success) {
    // Refresh to restore correct order on failure
    await refresh()
  } else {
    await refresh() // Sync with server state
  }
}
```

6. Add priority handler:
```typescript
async function handleSetPriority(requestId: string) {
  await setPriority(requestId)
  await refresh()
}
```

7. Add gate management handlers:
```typescript
async function handleCreateGate(gateNumber: number) {
  await createGate(gateNumber)
  await refreshGates()
}

async function handleRenameGate(gateId: string, newNumber: number) {
  await renameGate(gateId, newNumber)
  await refreshGates()
}

async function handleDeleteGate(gateId: string) {
  await deleteGate(gateId)
  await refreshGates()
}

async function handleToggleGateActive(gateId: string, isActive: boolean) {
  await toggleGateActive(gateId, isActive)
  await refreshGates()
}
```

8. Update gates fetch to include ALL gates (not just active) for management:
```typescript
// Fetch ALL gates for management tab
const { data: allGates, refresh: refreshGates } = await useAsyncData('all-gates', async () => {
  const { data, error } = await client
    .from('gates')
    .select('id, gate_number, is_active')
    .order('gate_number')
  if (error) throw error

  // Get queue counts
  const { data: counts } = await client
    .from('pickup_requests')
    .select('assigned_gate_id')
    .eq('status', 'in_queue')

  const countMap: Record<string, number> = {}
  for (const row of counts ?? []) {
    const gateId = (row as { assigned_gate_id: string | null }).assigned_gate_id
    if (gateId) countMap[gateId] = (countMap[gateId] || 0) + 1
  }

  return data.map(g => ({ ...g, queue_count: countMap[g.id] || 0 }))
})

// Active gates for tabs (filter from allGates)
const gates = computed(() => (allGates.value ?? []).filter(g => g.is_active))
```

**Template update:**
```html
<Tabs default-value="all" class="w-full">
  <TabsList class="flex-wrap">
    <TabsTrigger value="all">
      All Requests
      <span class="ml-2 text-xs bg-muted px-1.5 py-0.5 rounded">{{ activeRequests.length }}</span>
    </TabsTrigger>
    <TabsTrigger value="history">
      History
      <span class="ml-2 text-xs bg-muted px-1.5 py-0.5 rounded">{{ historyRequests.length }}</span>
    </TabsTrigger>
    <TabsTrigger
      v-for="gate in gatesWithQueues"
      :key="gate.id"
      :value="`gate-${gate.id}`"
    >
      Gate {{ gate.gate_number }}
      <span class="ml-2 text-xs bg-muted px-1.5 py-0.5 rounded">{{ gate.queue.length }}</span>
    </TabsTrigger>
    <TabsTrigger value="manage">
      Manage Gates
    </TabsTrigger>
  </TabsList>

  <TabsContent value="all" class="mt-4">
    <DataTable :columns="columns" :data="activeRequests" @row-click="handleRowClick" />
  </TabsContent>

  <TabsContent value="history" class="mt-4">
    <DataTable :columns="columns" :data="historyRequests" @row-click="handleRowClick" />
  </TabsContent>

  <TabsContent
    v-for="gate in gatesWithQueues"
    :key="gate.id"
    :value="`gate-${gate.id}`"
    class="mt-4"
  >
    <GateQueueList
      :key="gate.id"
      :gate-id="gate.id"
      :items="gate.queue"
      @reorder="(ids) => handleReorder(gate.id, ids)"
      @set-priority="handleSetPriority"
    />
  </TabsContent>

  <TabsContent value="manage" class="mt-4">
    <GateManagement
      :gates="allGates ?? []"
      @create="handleCreateGate"
      @rename="handleRenameGate"
      @delete="handleDeleteGate"
      @toggle-active="handleToggleGateActive"
    />
  </TabsContent>
</Tabs>
```

Note: Use `:key="gate.id"` on GateQueueList to force remount when switching gates (avoids useSortable stale state).
  </action>
  <verify>
```bash
cd /Users/thomas/Projects/tsg/warehouse-pickup-queue/staff && pnpm typecheck
```
  </verify>
  <done>
- Per-gate tabs render for each active gate
- GateQueueList shows in each gate tab with sortable queue
- Gate management tab shows GateManagement component
- All handlers wired and refresh data after operations
  </done>
</task>

<task type="auto">
  <name>Task 2: Update columns to include Move Gate action</name>
  <files>staff/app/components/dashboard/columns.ts</files>
  <action>
Add a "Move to Gate" dropdown/action in the columns for requests that are in_queue status:

In the action column cell renderer, add a dropdown or select that allows moving a request to a different gate. This uses the existing GateSelect pattern but triggers moveToGate instead of assignGate.

Options:
1. Add a separate "Move" dropdown alongside existing gate select
2. Or, make the GateSelect smart: if request is already in_queue, call moveToGate instead of assignGate

**Recommended approach:** Update the onGateSelect callback logic. In index.vue handleGateSelect, check if the request is already in_queue:

```typescript
async function handleGateSelect(requestId: string, gateId: string) {
  const request = requests.value?.find(r => r.id === requestId)
  if (request?.status === 'in_queue') {
    // Already in queue - this is a move operation
    await moveToGate(requestId, gateId)
  } else {
    // Not in queue - assign to queue
    await assignGate(requestId, gateId)
  }
  await refresh()
  // Update selected request if open
  if (selectedRequest.value?.id === requestId) {
    const updated = requests.value?.find(r => r.id === requestId)
    if (updated) selectedRequest.value = updated
  }
}
```

This way the existing GateSelect component works for both assign and move operations without UI changes.
  </action>
  <verify>
```bash
cd /Users/thomas/Projects/tsg/warehouse-pickup-queue/staff && pnpm typecheck
```
  </verify>
  <done>
- Gate select on in_queue requests triggers moveToGate
- Gate select on pending/approved requests triggers assignGate
- UI remains unchanged, behavior is context-aware
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete Phase 6 implementation:
- Per-gate tabs with drag-and-drop reordering
- Priority marking with visual badge
- Gate management (create, rename, delete, enable/disable)
- Move between gates via gate dropdown
- All operations sync to database atomically
  </what-built>
  <how-to-verify>
1. Start Supabase: `cd /Users/thomas/Projects/tsg/warehouse-pickup-queue && supabase start`
2. Start dev server: `cd staff && pnpm dev`
3. Login at http://localhost:3000 (staff@example.com / password123)
4. Test the following:

**Reordering:**
- Click a gate tab (e.g., "Gate 1")
- If queue has 2+ items, drag one item by the grip handle to reorder
- Verify new order persists after refresh

**Priority:**
- In a gate tab, click the priority button (arrow icon) on a non-priority item
- Verify it moves to position 2 and shows "Priority" badge
- Verify item at position 1 stays in place

**Gate Management:**
- Click "Manage Gates" tab
- Create a new gate (e.g., Gate 5)
- Rename an existing gate
- Try to disable a gate with customers (should show error)
- Disable an empty gate (should succeed and show greyed out)
- Delete an empty, disabled gate

**Move Between Gates:**
- In "All Requests" view, change gate assignment on an in_queue request
- Verify it moves to end of new gate's queue
- Verify old gate's queue positions compact (no gaps)
  </how-to-verify>
  <resume-signal>Type "approved" if all features work, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
1. `pnpm typecheck` passes
2. Per-gate tabs appear for each active gate
3. Drag-and-drop reorders queue within gate
4. Priority button moves request to position 2
5. Gate management CRUD works with validation
6. Move between gates works via gate dropdown
</verification>

<success_criteria>
- Dashboard shows per-gate tabs with queue counts
- GateQueueList renders with drag-and-drop working
- GateManagement panel accessible and functional
- Reorder, priority, and move operations sync to database
- Gate CRUD operations work with appropriate validation
- Human verification of complete feature set
</success_criteria>

<output>
After completion, create `.planning/phases/06-staff-advanced-queue-operations/06-04-SUMMARY.md`
</output>
