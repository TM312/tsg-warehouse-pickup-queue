---
phase: 02-netsuite-integration
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - lambda/handler.py
  - lambda/models/schemas.py
  - lambda/services/netsuite_service.py
  - lambda/services/cache_service.py
  - lambda/requirements.txt
autonomous: true

must_haves:
  truths:
    - "Lambda handler accepts POST with order_number and email fields"
    - "SuiteQL query finds orders by tranid (not internal ID)"
    - "Response includes company_name, item_count, po_number, email_match"
    - "Invalid orders return 404 with helpful error message"
    - "CORS headers are included in all responses"
    - "Order data is cached in Supabase pickup_requests table"
    - "Cached order data is reused for duplicate requests within TTL"
    - "Cache is bypassed only when no fresh entry exists"
  artifacts:
    - path: "lambda/handler.py"
      provides: "Lambda entry point with async wrapper"
      contains: "lambda_handler"
      min_lines: 40
    - path: "lambda/models/schemas.py"
      provides: "Pydantic request/response models"
      contains: "class OrderValidationRequest"
    - path: "lambda/services/netsuite_service.py"
      provides: "NetSuite API wrapper with SuiteQL"
      contains: "async def find_order"
    - path: "lambda/services/cache_service.py"
      provides: "Supabase cache operations for order data"
      contains: "class CacheService"
    - path: "lambda/requirements.txt"
      provides: "Python dependencies for Lambda layer"
      contains: "supabase"
  key_links:
    - from: "lambda/handler.py"
      to: "lambda/services/netsuite_service.py"
      via: "import and function call"
      pattern: "from services.netsuite_service import"
    - from: "lambda/handler.py"
      to: "lambda/services/cache_service.py"
      via: "cache check before NetSuite call"
      pattern: "from services.cache_service import"
    - from: "lambda/handler.py"
      to: "lambda/models/schemas.py"
      via: "Pydantic validation"
      pattern: "from models.schemas import"
    - from: "lambda/services/netsuite_service.py"
      to: "NetSuite API"
      via: "SuiteQL query"
      pattern: "suiteql|SuiteQL"
    - from: "lambda/services/cache_service.py"
      to: "Supabase pickup_requests table"
      via: "supabase-py client"
      pattern: "supabase.*pickup_requests"
---

<objective>
Implement Python Lambda function for NetSuite order validation with Supabase caching.

Purpose: Create the business logic that queries NetSuite for order details, validates customer email domain, and caches results in Supabase to reduce API calls for duplicate requests.

Output: Complete Lambda function code ready for deployment in `lambda/` directory.
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-netsuite-integration/02-CONTEXT.md
@.planning/phases/02-netsuite-integration/02-RESEARCH.md
@supabase/migrations/20260128000002_create_pickup_requests_table.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Pydantic schemas and Lambda handler</name>
  <files>lambda/models/__init__.py, lambda/models/schemas.py, lambda/handler.py</files>
  <action>
Create the Lambda entry point and data models:

**lambda/models/__init__.py:**
Empty file to make models a package.

**lambda/models/schemas.py:**
Define Pydantic v2 models for request/response validation:

```python
from pydantic import BaseModel, EmailStr, Field
from typing import Optional

class OrderValidationRequest(BaseModel):
    """Request body for order validation."""
    order_number: str = Field(..., min_length=1, max_length=50, description="NetSuite sales order number (e.g., SO-12345)")
    email: EmailStr = Field(..., description="Customer email for domain verification")

class OrderDetails(BaseModel):
    """Order details retrieved from NetSuite."""
    order_number: str
    company_name: str
    item_count: int
    po_number: Optional[str] = None
    status: str
    status_name: str
    email_match: bool = Field(..., description="True if submitted email domain matches NetSuite customer")
    valid_for_pickup: bool = Field(..., description="True if order status allows pickup")
    from_cache: bool = Field(default=False, description="True if data was served from cache")

class OrderValidationResponse(BaseModel):
    """Successful validation response."""
    success: bool = True
    order: OrderDetails

class ErrorResponse(BaseModel):
    """Error response with user-friendly message."""
    success: bool = False
    error: str
    error_code: str
    reference_id: Optional[str] = None  # For debugging
```

**lambda/handler.py:**
Create the Lambda entry point with async wrapper and cache integration:

```python
import asyncio
import json
import os
import uuid
from typing import Any

from models.schemas import OrderValidationRequest, OrderValidationResponse, ErrorResponse
from services.netsuite_service import NetSuiteService, OrderNotFoundError, NetSuiteError
from services.cache_service import CacheService
from pydantic import ValidationError

# CORS headers included in all responses
CORS_HEADERS = {
    "Content-Type": "application/json",
    "Access-Control-Allow-Origin": os.environ.get("ALLOWED_ORIGINS", "*"),
    "Access-Control-Allow-Headers": "Content-Type,X-Api-Key",
    "Access-Control-Allow-Methods": "POST,OPTIONS"
}

def lambda_handler(event: dict, context: Any) -> dict:
    """Lambda entry point - sync wrapper for async logic."""
    # Handle CORS preflight
    if event.get("httpMethod") == "OPTIONS":
        return build_response(200, {"message": "OK"})

    # Use existing event loop or create new one (handles warm starts)
    loop = asyncio.get_event_loop()
    return loop.run_until_complete(async_handler(event, context))

async def async_handler(event: dict, context: Any) -> dict:
    """Async handler for order validation with caching."""
    reference_id = str(uuid.uuid4())[:8]

    try:
        # Parse and validate request body
        body = json.loads(event.get("body", "{}"))
        request = OrderValidationRequest(**body)
    except json.JSONDecodeError:
        return build_response(400, ErrorResponse(
            error="Invalid JSON in request body",
            error_code="INVALID_JSON",
            reference_id=reference_id
        ).model_dump())
    except ValidationError as e:
        return build_response(400, ErrorResponse(
            error=f"Invalid request: {e.errors()[0]['msg']}",
            error_code="VALIDATION_ERROR",
            reference_id=reference_id
        ).model_dump())

    try:
        cache_service = CacheService()

        # Step 1: Check cache for existing fresh order data
        cached_order = await cache_service.get_cached_order(request.order_number)

        if cached_order:
            # Re-check email domain match with submitted email
            email_match = cache_service.check_email_domain_match(
                request.email,
                cached_order.get("netsuite_email", "")
            )

            from models.schemas import OrderDetails
            order = OrderDetails(
                order_number=cached_order["sales_order_number"],
                company_name=cached_order["company_name"],
                item_count=cached_order["item_count"],
                po_number=cached_order.get("po_number"),
                status=cached_order.get("netsuite_status", ""),
                status_name=cached_order.get("netsuite_status_name", "Unknown"),
                email_match=email_match,
                valid_for_pickup=cached_order.get("valid_for_pickup", True),
                from_cache=True
            )
            return build_response(200, OrderValidationResponse(order=order).model_dump())

        # Step 2: Query NetSuite for order
        ns_service = NetSuiteService()
        order, netsuite_email = await ns_service.find_order(request.order_number, request.email)

        # Step 3: Cache the result in Supabase for future requests
        await cache_service.cache_order(
            order_number=request.order_number,
            order_details=order,
            netsuite_email=netsuite_email
        )

        return build_response(200, OrderValidationResponse(order=order).model_dump())

    except OrderNotFoundError:
        return build_response(404, ErrorResponse(
            error=f"Order {request.order_number} not found. Make sure you're using the SO number from your confirmation email.",
            error_code="ORDER_NOT_FOUND",
            reference_id=reference_id
        ).model_dump())
    except NetSuiteError as e:
        return build_response(503, ErrorResponse(
            error="Unable to verify order at this time. Please try again.",
            error_code="NETSUITE_ERROR",
            reference_id=reference_id
        ).model_dump())
    except Exception as e:
        return build_response(500, ErrorResponse(
            error="An unexpected error occurred. Please try again.",
            error_code="INTERNAL_ERROR",
            reference_id=reference_id
        ).model_dump())

def build_response(status_code: int, body: dict) -> dict:
    """Build Lambda proxy response with CORS headers."""
    return {
        "statusCode": status_code,
        "headers": CORS_HEADERS,
        "body": json.dumps(body)
    }
```

Key patterns from research:
- Use asyncio.get_event_loop().run_until_complete() NOT asyncio.run() (Pitfall 1)
- CORS headers in Lambda response, not just API Gateway (Pattern 3)
- Reference IDs in errors for debugging (per CONTEXT.md discretion)
- User-friendly error messages per CONTEXT.md decisions
- Check cache BEFORE calling NetSuite (per CONTEXT.md caching strategy)
  </action>
  <verify>
Files exist and have correct structure:
- `ls lambda/models/__init__.py lambda/models/schemas.py lambda/handler.py`
- Python syntax check: `python3 -m py_compile lambda/handler.py lambda/models/schemas.py`
  </verify>
  <done>
Lambda handler and Pydantic schemas created with:
- OrderValidationRequest with order_number and email fields
- OrderValidationResponse with order details and from_cache flag
- ErrorResponse with user-friendly messages and reference IDs
- Async handler using get_event_loop pattern
- CORS headers in all responses
- Cache check before NetSuite call
  </done>
</task>

<task type="auto">
  <name>Task 2: Create NetSuite service with order lookup</name>
  <files>lambda/services/__init__.py, lambda/services/netsuite_service.py</files>
  <action>
Create the NetSuite integration service:

**lambda/services/__init__.py:**
Empty file to make services a package.

**lambda/services/netsuite_service.py:**
```python
import os
from typing import Optional, Tuple
from netsuite import NetSuite, Config, TokenAuth

from models.schemas import OrderDetails

# Valid statuses for pickup (from RESEARCH.md)
VALID_PICKUP_STATUSES = {"B", "C", "D", "E"}  # Pending Fulfillment, Partially Fulfilled, Pending Billing variants
FLAGGED_PICKUP_STATUSES = {"F"}  # Billed - may already be shipped

class OrderNotFoundError(Exception):
    """Raised when order number doesn't exist in NetSuite."""
    pass

class NetSuiteError(Exception):
    """Raised when NetSuite API fails."""
    pass

class NetSuiteService:
    """Service for NetSuite order validation."""

    def __init__(self):
        self.config = Config(
            account=os.environ["NETSUITE_ACCOUNT_ID"],
            auth=TokenAuth(
                consumer_key=os.environ["NETSUITE_CONSUMER_KEY"],
                consumer_secret=os.environ["NETSUITE_CONSUMER_SECRET"],
                token_id=os.environ["NETSUITE_TOKEN_ID"],
                token_secret=os.environ["NETSUITE_TOKEN_SECRET"],
            ),
        )

    async def find_order(self, order_number: str, customer_email: str) -> Tuple[OrderDetails, str]:
        """
        Find a sales order by order number and validate customer email.

        Args:
            order_number: NetSuite sales order number (tranid)
            customer_email: Email submitted by customer for domain verification

        Returns:
            Tuple of (OrderDetails with order info and email match status, netsuite_email for caching)

        Raises:
            OrderNotFoundError: If order doesn't exist
            NetSuiteError: If NetSuite API fails
        """
        try:
            ns = NetSuite(self.config)
            async with ns:
                # SuiteQL query - use transaction table with type filter (Pitfall 2)
                query = """
                    SELECT
                        t.id,
                        t.tranid,
                        t.status,
                        BUILTIN.DF(t.status) AS statusName,
                        t.entity,
                        c.companyname,
                        c.email AS customerEmail,
                        t.otherrefnum AS poNumber,
                        (SELECT COUNT(*) FROM transactionLine tl WHERE tl.transaction = t.id AND tl.mainline = 'F') AS itemCount
                    FROM transaction t
                    JOIN customer c ON t.entity = c.id
                    WHERE t.type = 'SalesOrd'
                    AND t.tranid = :orderNumber
                """

                response = await ns.rest_api.request(
                    "POST",
                    "/query/v1/suiteql",
                    json={"q": query.replace(":orderNumber", f"'{order_number}'")},
                    headers={"Prefer": "transient"},
                    params={"limit": "1"}
                )

                items = response.get("items", [])
                if not items:
                    raise OrderNotFoundError(f"Order {order_number} not found")

                order_data = items[0]

                # Get NetSuite customer email for caching
                netsuite_email = order_data.get("customerEmail") or ""

                # Check email domain match
                email_match = self._check_email_domain_match(customer_email, netsuite_email)

                # Check if status is valid for pickup
                status_code = order_data.get("status", "")
                valid_for_pickup = status_code in VALID_PICKUP_STATUSES

                order_details = OrderDetails(
                    order_number=order_data.get("tranid", order_number),
                    company_name=order_data.get("companyname", "Unknown"),
                    item_count=int(order_data.get("itemCount", 0)),
                    po_number=order_data.get("poNumber"),
                    status=status_code,
                    status_name=order_data.get("statusName", "Unknown"),
                    email_match=email_match,
                    valid_for_pickup=valid_for_pickup,
                    from_cache=False
                )

                return order_details, netsuite_email

        except OrderNotFoundError:
            raise
        except Exception as e:
            raise NetSuiteError(f"NetSuite API error: {str(e)}")

    def _check_email_domain_match(self, submitted_email: str, netsuite_email: str) -> bool:
        """
        Check if submitted email domain matches NetSuite customer email domain.

        Handles:
        - Null/empty NetSuite emails (returns False, customer flagged)
        - Case-insensitive comparison
        - Exact domain match (no subdomain flexibility for now)
        """
        if not netsuite_email:
            return False

        try:
            submitted_domain = submitted_email.lower().split("@")[1]
            netsuite_domain = netsuite_email.lower().split("@")[1]
            return submitted_domain == netsuite_domain
        except (IndexError, AttributeError):
            return False
```

Key patterns from research:
- SuiteQL queries transaction table with type='SalesOrd' (Pitfall 2)
- JOIN customer for email domain (not separate query)
- Filter mainline='F' for item count (gets actual line items, not summary lines)
- Handle null email gracefully (Pitfall 6)
- Use async context manager for NetSuite client
- Return netsuite_email separately for caching purposes
  </action>
  <verify>
Files exist:
- `ls lambda/services/__init__.py lambda/services/netsuite_service.py`
- Python syntax: `python3 -m py_compile lambda/services/netsuite_service.py`
  </verify>
  <done>
NetSuite service created with:
- SuiteQL query for order lookup by tranid
- Email domain verification with null handling
- Pickup validity check based on status codes
- Custom exceptions for error handling
- Returns both OrderDetails and netsuite_email for caching
  </done>
</task>

<task type="auto">
  <name>Task 3: Create cache service and requirements</name>
  <files>lambda/services/cache_service.py, lambda/requirements.txt</files>
  <action>
Create the Supabase cache service and update requirements:

**lambda/services/cache_service.py:**
```python
import os
from datetime import datetime, timedelta, timezone
from typing import Optional, Dict, Any
from supabase import create_client, Client

from models.schemas import OrderDetails

# Cache TTL in hours (from CONTEXT.md: 1-2 hours)
CACHE_TTL_HOURS = 2

class CacheService:
    """Service for caching order data in Supabase pickup_requests table."""

    def __init__(self):
        self.supabase: Client = create_client(
            os.environ["SUPABASE_URL"],
            os.environ["SUPABASE_SERVICE_ROLE_KEY"]
        )

    async def get_cached_order(self, order_number: str) -> Optional[Dict[str, Any]]:
        """
        Check for cached order data in Supabase.

        Returns cached data if:
        1. A pickup_request exists for this order_number
        2. It's not completed or cancelled (still active)
        3. It was created within the TTL window

        Args:
            order_number: Sales order number to look up

        Returns:
            Dict with cached order data if found and fresh, None otherwise
        """
        try:
            # Calculate TTL cutoff time
            cutoff_time = datetime.now(timezone.utc) - timedelta(hours=CACHE_TTL_HOURS)

            # Query for non-completed requests within TTL
            # Uses the sales_order_number column from pickup_requests table
            result = self.supabase.table("pickup_requests") \
                .select("*") \
                .eq("sales_order_number", order_number) \
                .not_.in_("status", ["completed", "cancelled"]) \
                .gte("created_at", cutoff_time.isoformat()) \
                .order("created_at", desc=True) \
                .limit(1) \
                .execute()

            if result.data and len(result.data) > 0:
                cached = result.data[0]
                # Only return if we have the NetSuite-cached fields populated
                if cached.get("company_name"):
                    return cached

            return None

        except Exception as e:
            # Cache miss on error - fall back to NetSuite
            print(f"Cache lookup error: {e}")
            return None

    async def cache_order(
        self,
        order_number: str,
        order_details: OrderDetails,
        netsuite_email: str
    ) -> None:
        """
        Cache order data by updating existing pickup_request or creating placeholder.

        Per CONTEXT.md: Store cached data in pickup_requests table alongside request data.
        This updates the NetSuite cache fields (company_name, item_count, po_number)
        on any existing pending request, or creates a new record for cache-only purposes.

        Args:
            order_number: Sales order number
            order_details: Order details from NetSuite
            netsuite_email: Customer email from NetSuite (for future domain checks)
        """
        try:
            # First, try to find an existing pending request to update
            existing = self.supabase.table("pickup_requests") \
                .select("id") \
                .eq("sales_order_number", order_number) \
                .not_.in_("status", ["completed", "cancelled"]) \
                .limit(1) \
                .execute()

            cache_data = {
                "company_name": order_details.company_name,
                "item_count": order_details.item_count,
                "po_number": order_details.po_number,
                # Store NetSuite status for cache reuse
                "netsuite_status": order_details.status,
                "netsuite_status_name": order_details.status_name,
                "valid_for_pickup": order_details.valid_for_pickup,
                # Store email for domain verification on cache hits
                "netsuite_email": netsuite_email
            }

            if existing.data and len(existing.data) > 0:
                # Update existing request with NetSuite data
                self.supabase.table("pickup_requests") \
                    .update(cache_data) \
                    .eq("id", existing.data[0]["id"]) \
                    .execute()
            else:
                # Create new cache-only record
                # This record will be converted to a real request when customer submits
                self.supabase.table("pickup_requests") \
                    .insert({
                        "sales_order_number": order_number,
                        "customer_email": "",  # Will be filled on actual submission
                        "status": "pending",  # Placeholder status
                        **cache_data
                    }) \
                    .execute()

        except Exception as e:
            # Cache write failure is non-fatal - log and continue
            print(f"Cache write error: {e}")

    def check_email_domain_match(self, submitted_email: str, netsuite_email: str) -> bool:
        """
        Check if submitted email domain matches NetSuite customer email domain.

        Replicates logic from NetSuiteService for cache hits.
        """
        if not netsuite_email:
            return False

        try:
            submitted_domain = submitted_email.lower().split("@")[1]
            netsuite_domain = netsuite_email.lower().split("@")[1]
            return submitted_domain == netsuite_domain
        except (IndexError, AttributeError):
            return False
```

**lambda/requirements.txt:**
```
netsuite[orjson]==0.12.0
pydantic>=2.0.0,<3.0.0
supabase>=2.0.0,<3.0.0
```

Key design decisions:
- 2-hour TTL per CONTEXT.md guidance
- Cache stored in pickup_requests table per CONTEXT.md
- Non-fatal cache errors (fall back to NetSuite on cache miss/error)
- Uses service role key to bypass RLS for cache operations
- Stores netsuite_email for re-checking domain match on cache hits
- Updates existing pending requests rather than creating duplicates

Note: The pickup_requests table needs additional columns (netsuite_status, netsuite_status_name, valid_for_pickup, netsuite_email) added via migration. These are cached fields that don't affect the existing schema - they can be added as nullable columns.
  </action>
  <verify>
Files exist:
- `ls lambda/services/cache_service.py lambda/requirements.txt`
- Python syntax: `python3 -m py_compile lambda/services/cache_service.py`
- requirements.txt contains netsuite, pydantic, and supabase
  </verify>
  <done>
Cache service created with:
- Supabase client using service role key
- get_cached_order checking TTL and status
- cache_order updating or creating pickup_request records
- 2-hour cache TTL
- Non-fatal error handling
- requirements.txt updated with supabase dependency
  </done>
</task>

</tasks>

<verification>
1. All Python files pass syntax check: `python3 -m py_compile lambda/**/*.py`
2. Lambda directory structure matches research pattern:
   - lambda/handler.py
   - lambda/models/schemas.py
   - lambda/services/netsuite_service.py
   - lambda/services/cache_service.py
   - lambda/requirements.txt
3. SuiteQL query uses transaction table with type filter (not salesorder table)
4. Handler uses get_event_loop pattern for async
5. Handler checks cache before calling NetSuite
6. Cache service uses Supabase pickup_requests table
</verification>

<success_criteria>
- lambda/handler.py exists with lambda_handler entry point and cache integration
- lambda/models/schemas.py defines request/response Pydantic models with from_cache flag
- lambda/services/netsuite_service.py implements SuiteQL order lookup
- lambda/services/cache_service.py implements Supabase caching with TTL
- lambda/requirements.txt lists netsuite, pydantic, and supabase dependencies
- All Python files pass syntax validation
- Handler includes CORS headers in responses
- Handler checks cache before calling NetSuite API
- Cache miss triggers NetSuite query and stores result
- Error messages follow CONTEXT.md guidelines (helpful for missing orders, vague for email mismatch)
</success_criteria>

<output>
After completion, create `.planning/phases/02-netsuite-integration/02-02-SUMMARY.md`
</output>
