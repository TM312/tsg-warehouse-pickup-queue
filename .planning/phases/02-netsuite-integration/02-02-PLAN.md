---
phase: 02-netsuite-integration
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - lambda/handler.py
  - lambda/models/schemas.py
  - lambda/services/netsuite_service.py
  - lambda/requirements.txt
autonomous: true

must_haves:
  truths:
    - "Lambda handler accepts POST with order_number and email fields"
    - "SuiteQL query finds orders by tranid (not internal ID)"
    - "Response includes company_name, item_count, po_number, email_match"
    - "Invalid orders return 404 with helpful error message"
    - "CORS headers are included in all responses"
  artifacts:
    - path: "lambda/handler.py"
      provides: "Lambda entry point with async wrapper"
      contains: "lambda_handler"
      min_lines: 40
    - path: "lambda/models/schemas.py"
      provides: "Pydantic request/response models"
      contains: "class OrderValidationRequest"
    - path: "lambda/services/netsuite_service.py"
      provides: "NetSuite API wrapper with SuiteQL"
      contains: "async def find_order"
    - path: "lambda/requirements.txt"
      provides: "Python dependencies for Lambda layer"
      contains: "netsuite"
  key_links:
    - from: "lambda/handler.py"
      to: "lambda/services/netsuite_service.py"
      via: "import and function call"
      pattern: "from services.netsuite_service import"
    - from: "lambda/handler.py"
      to: "lambda/models/schemas.py"
      via: "Pydantic validation"
      pattern: "from models.schemas import"
    - from: "lambda/services/netsuite_service.py"
      to: "NetSuite API"
      via: "SuiteQL query"
      pattern: "suiteql|SuiteQL"
---

<objective>
Implement Python Lambda function for NetSuite order validation.

Purpose: Create the business logic that queries NetSuite for order details and validates customer email domain against the customer record.

Output: Complete Lambda function code ready for deployment in `lambda/` directory.
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-netsuite-integration/02-CONTEXT.md
@.planning/phases/02-netsuite-integration/02-RESEARCH.md
@supabase/migrations/20260128000002_create_pickup_requests_table.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Pydantic schemas and Lambda handler</name>
  <files>lambda/models/__init__.py, lambda/models/schemas.py, lambda/handler.py</files>
  <action>
Create the Lambda entry point and data models:

**lambda/models/__init__.py:**
Empty file to make models a package.

**lambda/models/schemas.py:**
Define Pydantic v2 models for request/response validation:

```python
from pydantic import BaseModel, EmailStr, Field
from typing import Optional

class OrderValidationRequest(BaseModel):
    """Request body for order validation."""
    order_number: str = Field(..., min_length=1, max_length=50, description="NetSuite sales order number (e.g., SO-12345)")
    email: EmailStr = Field(..., description="Customer email for domain verification")

class OrderDetails(BaseModel):
    """Order details retrieved from NetSuite."""
    order_number: str
    company_name: str
    item_count: int
    po_number: Optional[str] = None
    status: str
    status_name: str
    email_match: bool = Field(..., description="True if submitted email domain matches NetSuite customer")
    valid_for_pickup: bool = Field(..., description="True if order status allows pickup")

class OrderValidationResponse(BaseModel):
    """Successful validation response."""
    success: bool = True
    order: OrderDetails

class ErrorResponse(BaseModel):
    """Error response with user-friendly message."""
    success: bool = False
    error: str
    error_code: str
    reference_id: Optional[str] = None  # For debugging
```

**lambda/handler.py:**
Create the Lambda entry point with async wrapper:

```python
import asyncio
import json
import os
import uuid
from typing import Any

from models.schemas import OrderValidationRequest, OrderValidationResponse, ErrorResponse
from services.netsuite_service import NetSuiteService, OrderNotFoundError, NetSuiteError
from pydantic import ValidationError

# CORS headers included in all responses
CORS_HEADERS = {
    "Content-Type": "application/json",
    "Access-Control-Allow-Origin": os.environ.get("ALLOWED_ORIGINS", "*"),
    "Access-Control-Allow-Headers": "Content-Type,X-Api-Key",
    "Access-Control-Allow-Methods": "POST,OPTIONS"
}

def lambda_handler(event: dict, context: Any) -> dict:
    """Lambda entry point - sync wrapper for async logic."""
    # Handle CORS preflight
    if event.get("httpMethod") == "OPTIONS":
        return build_response(200, {"message": "OK"})

    # Use existing event loop or create new one (handles warm starts)
    loop = asyncio.get_event_loop()
    return loop.run_until_complete(async_handler(event, context))

async def async_handler(event: dict, context: Any) -> dict:
    """Async handler for order validation."""
    reference_id = str(uuid.uuid4())[:8]

    try:
        # Parse and validate request body
        body = json.loads(event.get("body", "{}"))
        request = OrderValidationRequest(**body)
    except json.JSONDecodeError:
        return build_response(400, ErrorResponse(
            error="Invalid JSON in request body",
            error_code="INVALID_JSON",
            reference_id=reference_id
        ).model_dump())
    except ValidationError as e:
        return build_response(400, ErrorResponse(
            error=f"Invalid request: {e.errors()[0]['msg']}",
            error_code="VALIDATION_ERROR",
            reference_id=reference_id
        ).model_dump())

    try:
        # Query NetSuite for order
        ns_service = NetSuiteService()
        order = await ns_service.find_order(request.order_number, request.email)

        return build_response(200, OrderValidationResponse(order=order).model_dump())

    except OrderNotFoundError:
        return build_response(404, ErrorResponse(
            error=f"Order {request.order_number} not found. Make sure you're using the SO number from your confirmation email.",
            error_code="ORDER_NOT_FOUND",
            reference_id=reference_id
        ).model_dump())
    except NetSuiteError as e:
        return build_response(503, ErrorResponse(
            error="Unable to verify order at this time. Please try again.",
            error_code="NETSUITE_ERROR",
            reference_id=reference_id
        ).model_dump())
    except Exception as e:
        return build_response(500, ErrorResponse(
            error="An unexpected error occurred. Please try again.",
            error_code="INTERNAL_ERROR",
            reference_id=reference_id
        ).model_dump())

def build_response(status_code: int, body: dict) -> dict:
    """Build Lambda proxy response with CORS headers."""
    return {
        "statusCode": status_code,
        "headers": CORS_HEADERS,
        "body": json.dumps(body)
    }
```

Key patterns from research:
- Use asyncio.get_event_loop().run_until_complete() NOT asyncio.run() (Pitfall 1)
- CORS headers in Lambda response, not just API Gateway (Pattern 3)
- Reference IDs in errors for debugging (per CONTEXT.md discretion)
- User-friendly error messages per CONTEXT.md decisions
  </action>
  <verify>
Files exist and have correct structure:
- `ls lambda/models/__init__.py lambda/models/schemas.py lambda/handler.py`
- Python syntax check: `python3 -m py_compile lambda/handler.py lambda/models/schemas.py`
  </verify>
  <done>
Lambda handler and Pydantic schemas created with:
- OrderValidationRequest with order_number and email fields
- OrderValidationResponse with order details
- ErrorResponse with user-friendly messages and reference IDs
- Async handler using get_event_loop pattern
- CORS headers in all responses
  </done>
</task>

<task type="auto">
  <name>Task 2: Create NetSuite service and requirements</name>
  <files>lambda/services/__init__.py, lambda/services/netsuite_service.py, lambda/requirements.txt</files>
  <action>
Create the NetSuite integration service:

**lambda/services/__init__.py:**
Empty file to make services a package.

**lambda/services/netsuite_service.py:**
```python
import os
from typing import Optional
from netsuite import NetSuite, Config, TokenAuth

from models.schemas import OrderDetails

# Valid statuses for pickup (from RESEARCH.md)
VALID_PICKUP_STATUSES = {"B", "C", "D", "E"}  # Pending Fulfillment, Partially Fulfilled, Pending Billing variants
FLAGGED_PICKUP_STATUSES = {"F"}  # Billed - may already be shipped

class OrderNotFoundError(Exception):
    """Raised when order number doesn't exist in NetSuite."""
    pass

class NetSuiteError(Exception):
    """Raised when NetSuite API fails."""
    pass

class NetSuiteService:
    """Service for NetSuite order validation."""

    def __init__(self):
        self.config = Config(
            account=os.environ["NETSUITE_ACCOUNT_ID"],
            auth=TokenAuth(
                consumer_key=os.environ["NETSUITE_CONSUMER_KEY"],
                consumer_secret=os.environ["NETSUITE_CONSUMER_SECRET"],
                token_id=os.environ["NETSUITE_TOKEN_ID"],
                token_secret=os.environ["NETSUITE_TOKEN_SECRET"],
            ),
        )

    async def find_order(self, order_number: str, customer_email: str) -> OrderDetails:
        """
        Find a sales order by order number and validate customer email.

        Args:
            order_number: NetSuite sales order number (tranid)
            customer_email: Email submitted by customer for domain verification

        Returns:
            OrderDetails with order info and email match status

        Raises:
            OrderNotFoundError: If order doesn't exist
            NetSuiteError: If NetSuite API fails
        """
        try:
            ns = NetSuite(self.config)
            async with ns:
                # SuiteQL query - use transaction table with type filter (Pitfall 2)
                query = """
                    SELECT
                        t.id,
                        t.tranid,
                        t.status,
                        BUILTIN.DF(t.status) AS statusName,
                        t.entity,
                        c.companyname,
                        c.email AS customerEmail,
                        t.otherrefnum AS poNumber,
                        (SELECT COUNT(*) FROM transactionLine tl WHERE tl.transaction = t.id AND tl.mainline = 'F') AS itemCount
                    FROM transaction t
                    JOIN customer c ON t.entity = c.id
                    WHERE t.type = 'SalesOrd'
                    AND t.tranid = :orderNumber
                """

                response = await ns.rest_api.request(
                    "POST",
                    "/query/v1/suiteql",
                    json={"q": query.replace(":orderNumber", f"'{order_number}'")},
                    headers={"Prefer": "transient"},
                    params={"limit": "1"}
                )

                items = response.get("items", [])
                if not items:
                    raise OrderNotFoundError(f"Order {order_number} not found")

                order_data = items[0]

                # Check email domain match
                netsuite_email = order_data.get("customerEmail") or ""
                email_match = self._check_email_domain_match(customer_email, netsuite_email)

                # Check if status is valid for pickup
                status_code = order_data.get("status", "")
                valid_for_pickup = status_code in VALID_PICKUP_STATUSES

                return OrderDetails(
                    order_number=order_data.get("tranid", order_number),
                    company_name=order_data.get("companyname", "Unknown"),
                    item_count=int(order_data.get("itemCount", 0)),
                    po_number=order_data.get("poNumber"),
                    status=status_code,
                    status_name=order_data.get("statusName", "Unknown"),
                    email_match=email_match,
                    valid_for_pickup=valid_for_pickup
                )

        except OrderNotFoundError:
            raise
        except Exception as e:
            raise NetSuiteError(f"NetSuite API error: {str(e)}")

    def _check_email_domain_match(self, submitted_email: str, netsuite_email: str) -> bool:
        """
        Check if submitted email domain matches NetSuite customer email domain.

        Handles:
        - Null/empty NetSuite emails (returns False, customer flagged)
        - Case-insensitive comparison
        - Exact domain match (no subdomain flexibility for now)
        """
        if not netsuite_email:
            return False

        try:
            submitted_domain = submitted_email.lower().split("@")[1]
            netsuite_domain = netsuite_email.lower().split("@")[1]
            return submitted_domain == netsuite_domain
        except (IndexError, AttributeError):
            return False
```

**lambda/requirements.txt:**
```
netsuite[orjson]==0.12.0
pydantic>=2.0.0,<3.0.0
```

Key patterns from research:
- SuiteQL queries transaction table with type='SalesOrd' (Pitfall 2)
- JOIN customer for email domain (not separate query)
- Filter mainline='F' for item count (gets actual line items, not summary lines)
- Handle null email gracefully (Pitfall 6)
- Use async context manager for NetSuite client
  </action>
  <verify>
Files exist:
- `ls lambda/services/__init__.py lambda/services/netsuite_service.py lambda/requirements.txt`
- Python syntax: `python3 -m py_compile lambda/services/netsuite_service.py`
- requirements.txt contains netsuite and pydantic
  </verify>
  <done>
NetSuite service created with:
- SuiteQL query for order lookup by tranid
- Email domain verification with null handling
- Pickup validity check based on status codes
- Custom exceptions for error handling
- requirements.txt with netsuite[orjson] and pydantic
  </done>
</task>

</tasks>

<verification>
1. All Python files pass syntax check: `python3 -m py_compile lambda/**/*.py`
2. Lambda directory structure matches research pattern:
   - lambda/handler.py
   - lambda/models/schemas.py
   - lambda/services/netsuite_service.py
   - lambda/requirements.txt
3. SuiteQL query uses transaction table with type filter (not salesorder table)
4. Handler uses get_event_loop pattern for async
</verification>

<success_criteria>
- lambda/handler.py exists with lambda_handler entry point
- lambda/models/schemas.py defines request/response Pydantic models
- lambda/services/netsuite_service.py implements SuiteQL order lookup
- lambda/requirements.txt lists netsuite and pydantic dependencies
- All Python files pass syntax validation
- Handler includes CORS headers in responses
- Error messages follow CONTEXT.md guidelines (helpful for missing orders, vague for email mismatch)
</success_criteria>

<output>
After completion, create `.planning/phases/02-netsuite-integration/02-02-SUMMARY.md`
</output>
