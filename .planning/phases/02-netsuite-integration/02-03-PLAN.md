---
phase: 02-netsuite-integration
plan: 03
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - lambda/build-layer.sh
  - infra/terraform.tfvars.example
autonomous: false

user_setup:
  - service: aws
    why: "Lambda deployment and API Gateway"
    env_vars:
      - name: AWS_ACCESS_KEY_ID
        source: "AWS IAM Console -> Users -> Security credentials -> Create access key"
      - name: AWS_SECRET_ACCESS_KEY
        source: "AWS IAM Console -> Users -> Security credentials -> Create access key"
      - name: AWS_REGION
        source: "Set to your preferred region (e.g., us-east-1)"
  - service: netsuite
    why: "Order validation API credentials"
    env_vars:
      - name: TF_VAR_netsuite_account_id
        source: "NetSuite -> Setup -> Company -> Company Information -> Account ID"
      - name: TF_VAR_netsuite_consumer_key
        source: "NetSuite -> Setup -> Integration -> Manage Integrations -> Your Integration -> Consumer Key"
      - name: TF_VAR_netsuite_consumer_secret
        source: "NetSuite -> Setup -> Integration -> Manage Integrations -> Your Integration -> Consumer Secret"
      - name: TF_VAR_netsuite_token_id
        source: "NetSuite -> Setup -> Users/Roles -> Access Tokens -> Your Token -> Token ID"
      - name: TF_VAR_netsuite_token_secret
        source: "NetSuite -> Setup -> Users/Roles -> Access Tokens -> Your Token -> Token Secret"

must_haves:
  truths:
    - "Lambda layer builds successfully with all Python dependencies"
    - "OpenTofu apply completes without errors"
    - "API endpoint returns valid response for test request"
    - "API key is required (requests without key return 403)"
  artifacts:
    - path: "lambda/build-layer.sh"
      provides: "Script to build Lambda layer with Docker"
      contains: "pip install"
    - path: "lambda/layer/python.zip"
      provides: "Built Lambda layer with dependencies"
    - path: "infra/terraform.tfvars.example"
      provides: "Example configuration for credentials"
      contains: "netsuite_account_id"
  key_links:
    - from: "infra/lambda.tf"
      to: "lambda/layer/python.zip"
      via: "Lambda layer source"
      pattern: "python\\.zip"
    - from: "API Gateway"
      to: "Lambda function"
      via: "AWS_PROXY integration"
      pattern: "validate-order"
---

<objective>
Build Lambda layer and deploy NetSuite integration to AWS.

Purpose: Complete the deployment pipeline and verify the integration works end-to-end with real AWS infrastructure.

Output: Working API endpoint that validates orders against NetSuite.
</objective>

<context>
@.planning/PROJECT.md
@.planning/phases/02-netsuite-integration/02-CONTEXT.md
@.planning/phases/02-netsuite-integration/02-RESEARCH.md
@.planning/phases/02-netsuite-integration/02-01-SUMMARY.md
@.planning/phases/02-netsuite-integration/02-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Lambda layer build script and example tfvars</name>
  <files>lambda/build-layer.sh, infra/terraform.tfvars.example, lambda/.gitignore</files>
  <action>
Create the build script and configuration templates:

**lambda/build-layer.sh:**
```bash
#!/bin/bash
# Build Lambda layer with Python dependencies using Docker
# This ensures dependencies are compiled for Amazon Linux 2 (Lambda runtime)

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LAYER_DIR="${SCRIPT_DIR}/layer"

echo "=== Building Lambda Layer ==="

# Clean previous build
rm -rf "${LAYER_DIR}"
mkdir -p "${LAYER_DIR}/python"

# Build using Docker with Amazon Linux 2 base
# This ensures native dependencies (like orjson) are compiled for Lambda
docker run --rm \
    -v "${SCRIPT_DIR}:/var/task" \
    -w /var/task \
    public.ecr.aws/lambda/python:3.12 \
    pip install -r requirements.txt -t layer/python --no-cache-dir

# Create zip for Lambda layer
cd "${LAYER_DIR}"
zip -r python.zip python

echo "=== Layer built: ${LAYER_DIR}/python.zip ==="
echo "Size: $(du -h python.zip | cut -f1)"
```

Make it executable: `chmod +x lambda/build-layer.sh`

**infra/terraform.tfvars.example:**
```hcl
# AWS Configuration
aws_region  = "us-east-1"
environment = "production"

# NetSuite Credentials (obtain from NetSuite admin console)
# WARNING: Never commit actual credentials to git!
# Either:
# 1. Copy this file to terraform.tfvars and fill in values (terraform.tfvars is gitignored)
# 2. Set environment variables: TF_VAR_netsuite_account_id, etc.

netsuite_account_id     = "YOUR_ACCOUNT_ID"
netsuite_consumer_key   = "YOUR_CONSUMER_KEY"
netsuite_consumer_secret = "YOUR_CONSUMER_SECRET"
netsuite_token_id       = "YOUR_TOKEN_ID"
netsuite_token_secret   = "YOUR_TOKEN_SECRET"

# CORS Configuration
# Set to specific origin in production (e.g., "https://pickup.yourcompany.com")
allowed_origins = "*"
```

**lambda/.gitignore:**
```
# Built layer (large, regenerated)
layer/

# Python artifacts
__pycache__/
*.pyc
*.pyo
.pytest_cache/

# IDE
.vscode/
.idea/
```

**infra/.gitignore:**
```
# Terraform state (contains secrets)
*.tfstate
*.tfstate.*
.terraform/
.terraform.lock.hcl

# Actual credentials (use tfvars.example as template)
terraform.tfvars
*.auto.tfvars

# Crash logs
crash.log
```
  </action>
  <verify>
- `ls -la lambda/build-layer.sh` shows executable permissions
- `cat infra/terraform.tfvars.example` shows all netsuite_* variables
- `cat lambda/.gitignore` includes layer/
- `cat infra/.gitignore` includes terraform.tfvars
  </verify>
  <done>
Build script created with Docker-based layer building for Lambda compatibility.
Example tfvars shows all required variables.
Gitignore files prevent committing secrets and build artifacts.
  </done>
</task>

<task type="auto">
  <name>Task 2: Build Lambda layer and deploy infrastructure</name>
  <files>lambda/layer/python.zip</files>
  <action>
Execute the build and deployment:

1. **Build the Lambda layer:**
```bash
cd lambda && ./build-layer.sh
```
Verify output shows successful pip install and zip creation.
Layer should be ~10-20MB (netsuite + pydantic + orjson).

2. **Initialize and deploy with OpenTofu:**
```bash
cd infra
tofu init
tofu plan
```

If credentials are not set via environment variables, prompt user to set them:
```bash
export TF_VAR_netsuite_account_id="..."
export TF_VAR_netsuite_consumer_key="..."
export TF_VAR_netsuite_consumer_secret="..."
export TF_VAR_netsuite_token_id="..."
export TF_VAR_netsuite_token_secret="..."
```

3. **Apply infrastructure:**
```bash
tofu apply
```
Type "yes" when prompted.

4. **Capture outputs:**
```bash
tofu output api_endpoint
tofu output api_key_value
```
Save these for verification task.

Note: If AWS credentials are not configured, this will fail with auth error.
That's expected - the checkpoint will handle user authentication.
  </action>
  <verify>
- `ls -la lambda/layer/python.zip` exists and is >5MB
- `cd infra && tofu output api_endpoint` returns a URL
- `cd infra && tofu output lambda_function_name` returns function name
  </verify>
  <done>
Lambda layer built with all dependencies.
OpenTofu successfully deployed Lambda + API Gateway.
API endpoint URL and API key captured for verification.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify API endpoint works</name>
  <what-built>
NetSuite integration Lambda deployed to AWS with API Gateway endpoint:
- POST /validate-order endpoint requiring API key
- Lambda function with NetSuite SuiteQL integration
- Usage plan with rate limiting (100 req/sec, 200 burst)
  </what-built>
  <how-to-verify>
1. Get the API endpoint and key from OpenTofu outputs:
```bash
cd infra
API_URL=$(tofu output -raw api_endpoint)
API_KEY=$(tofu output -raw api_key_value)
echo "Endpoint: $API_URL"
```

2. Test without API key (should return 403 Forbidden):
```bash
curl -X POST "$API_URL" \
  -H "Content-Type: application/json" \
  -d '{"order_number": "SO-12345", "email": "test@example.com"}'
```
Expected: 403 Forbidden response

3. Test with API key and invalid order (should return 404):
```bash
curl -X POST "$API_URL" \
  -H "Content-Type: application/json" \
  -H "X-Api-Key: $API_KEY" \
  -d '{"order_number": "SO-INVALID-12345", "email": "test@example.com"}'
```
Expected: 404 response with helpful error message

4. Test with API key and valid order (requires real NetSuite order):
```bash
curl -X POST "$API_URL" \
  -H "Content-Type: application/json" \
  -H "X-Api-Key: $API_KEY" \
  -d '{"order_number": "YOUR_REAL_ORDER_NUMBER", "email": "your@company.com"}'
```
Expected: 200 response with order details (company_name, item_count, etc.)

5. Verify CORS headers are present:
```bash
curl -I -X OPTIONS "$API_URL" \
  -H "Origin: http://localhost:3000"
```
Expected: Access-Control-Allow-* headers in response

**What to check:**
- [ ] Request without API key returns 403
- [ ] Invalid order returns 404 with helpful message
- [ ] Valid order returns 200 with order details
- [ ] CORS preflight returns proper headers
  </how-to-verify>
  <resume-signal>
Type "approved" if all checks pass, or describe any issues encountered.
If NetSuite credentials are not yet available, type "defer-netsuite" to approve infrastructure-only.
  </resume-signal>
</task>

</tasks>

<verification>
1. Lambda layer exists at lambda/layer/python.zip
2. OpenTofu shows successful apply with no errors
3. API endpoint responds to requests
4. API key authentication enforced (403 without key)
5. CORS headers present in responses
</verification>

<success_criteria>
- lambda/build-layer.sh is executable and builds layer successfully
- lambda/layer/python.zip exists with Python dependencies
- infra/terraform.tfvars.example documents all required variables
- OpenTofu apply completes successfully
- API endpoint URL is accessible
- Requests without API key return 403
- Invalid orders return 404 with user-friendly message
- Valid orders return 200 with order details
</success_criteria>

<output>
After completion, create `.planning/phases/02-netsuite-integration/02-03-SUMMARY.md`
</output>
