---
phase: 08-real-time-infrastructure
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - customer/app/composables/useRealtimeStatus.ts
  - customer/app/components/ConnectionStatus.vue
autonomous: true

must_haves:
  truths:
    - "Customer can subscribe to changes for their specific request only"
    - "Customer sees connection status when WebSocket disconnects"
    - "Subscription filters by request ID (does not receive other customers' data)"
    - "Channel cleanup occurs on component unmount"
    - "DELETE events are handled correctly despite filter limitation"
  artifacts:
    - path: "customer/app/composables/useRealtimeStatus.ts"
      provides: "Customer realtime subscription composable"
      exports: ["useRealtimeStatus"]
    - path: "customer/app/components/ConnectionStatus.vue"
      provides: "Visual feedback for connection state"
  key_links:
    - from: "customer/app/composables/useRealtimeStatus.ts"
      to: "useSupabaseClient"
      via: "Nuxt Supabase module"
      pattern: "useSupabaseClient\\(\\)"
    - from: "customer/app/composables/useRealtimeStatus.ts"
      to: "pickup_requests table"
      via: "postgres_changes subscription with filter"
      pattern: "filter:\\s*`id=eq\\.\\$"
---

<objective>
Create customer-specific realtime subscription composable with ID-based filtering.

Purpose: Customers should only receive updates about their own pickup request, not see other customers' data. This composable enables the status page to receive live updates for a single request ID.

Output: useRealtimeStatus composable with filtered subscription and ConnectionStatus UI component.
</objective>

<execution_context>
@/Users/thomas/.claude/get-shit-done/workflows/execute-plan.md
@/Users/thomas/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-real-time-infrastructure/08-RESEARCH.md
@customer/app/composables/useBusinessHours.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useRealtimeStatus composable for customer app</name>
  <files>customer/app/composables/useRealtimeStatus.ts</files>
  <action>
Create a composable that handles realtime subscription to a single pickup request by ID.

Requirements:
1. Accept `requestId` parameter (string) for filtering
2. Use `useSupabaseClient()` from @nuxtjs/supabase
3. Track connection status: 'connecting' | 'connected' | 'disconnected'
4. Channel name: `pickup-request-${requestId}` (unique per request)
5. Filter subscription to only receive changes for this specific ID: `filter: \`id=eq.${requestId}\``
6. Handle DELETE filter limitation: check payload.old.id in callback
7. Accept `onUpdate` callback that receives the payload with new/old data
8. Include visibility-based reconnection and data refresh
9. Return `{ status, subscribe, unsubscribe }` where status is a readonly ref

Implementation pattern from research:
```typescript
import type { RealtimeChannel, RealtimePostgresChangesPayload } from '@supabase/supabase-js'
import { useDocumentVisibility } from '@vueuse/core'

export type ConnectionStatus = 'connecting' | 'connected' | 'disconnected'

// Define payload type for pickup_requests (simplified - not using full database types)
export interface PickupRequestPayload {
  id: string
  status: string
  queue_position: number | null
  assigned_gate_id: string | null
  // Add other fields as needed
  [key: string]: unknown
}

export function useRealtimeStatus(requestId: string) {
  const client = useSupabaseClient()
  const visibility = useDocumentVisibility()

  const status = ref<ConnectionStatus>('connecting')
  let channel: RealtimeChannel | null = null
  let updateCallback: ((payload: RealtimePostgresChangesPayload<PickupRequestPayload>) => void) | null = null

  const subscribe = (
    onUpdate: (payload: RealtimePostgresChangesPayload<PickupRequestPayload>) => void
  ) => {
    updateCallback = onUpdate
    channel = client
      .channel(`pickup-request-${requestId}`)
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'pickup_requests',
          filter: `id=eq.${requestId}`
        },
        (payload) => {
          // Handle DELETE filter limitation - filter doesn't work for DELETE
          // Check that this is actually our request
          if (payload.eventType === 'DELETE') {
            const oldId = (payload.old as { id?: string })?.id
            if (oldId !== requestId) {
              return // Ignore DELETE for other requests
            }
          }
          onUpdate(payload as RealtimePostgresChangesPayload<PickupRequestPayload>)
        }
      )
      .subscribe((subscribeStatus) => {
        if (subscribeStatus === 'SUBSCRIBED') {
          status.value = 'connected'
        } else if (subscribeStatus === 'CLOSED' || subscribeStatus === 'TIMED_OUT' || subscribeStatus === 'CHANNEL_ERROR') {
          status.value = 'disconnected'
        }
      })
  }

  const unsubscribe = () => {
    if (channel) {
      client.removeChannel(channel)
      channel = null
    }
  }

  // Auto-reconnect on visibility change
  watch(visibility, async (current, previous) => {
    if (current === 'visible' && previous === 'hidden') {
      // Signal to caller they should refresh data
      // Note: For customer, we'll trigger onUpdate with a special "refresh" indicator
      // Or caller can just re-fetch when visibility changes
      if (status.value !== 'connected' && updateCallback) {
        unsubscribe()
        subscribe(updateCallback)
      }
    }
  })

  return {
    status: readonly(status),
    subscribe,
    unsubscribe
  }
}
```

Key differences from staff composable:
- Takes requestId parameter for filtering
- Filter parameter in subscription config
- Explicit DELETE event handling (filter limitation workaround)
- Payload includes both old and new for state transitions
  </action>
  <verify>
TypeScript compilation: `cd customer && pnpm typecheck` passes without errors related to useRealtimeStatus.
  </verify>
  <done>Composable exports useRealtimeStatus that accepts requestId and provides status, subscribe, unsubscribe.</done>
</task>

<task type="auto">
  <name>Task 2: Create ConnectionStatus component for customer app</name>
  <files>customer/app/components/ConnectionStatus.vue</files>
  <action>
Create a Vue component that displays connection status when not connected. This is similar to the staff version but styled appropriately for customer-facing UI.

Requirements:
1. Accept `status` prop of type ConnectionStatus
2. Only show when status !== 'connected'
3. Fixed position bottom-center (mobile-friendly positioning)
4. Visual styles:
   - connecting: yellow/amber styling
   - disconnected: subtle warning styling
5. Messages should be customer-friendly:
   - connecting: "Connecting..."
   - disconnected: "Reconnecting to live updates..."

Implementation:
```vue
<template>
  <div
    v-if="status !== 'connected'"
    class="fixed bottom-4 left-1/2 -translate-x-1/2 px-4 py-2 rounded-lg text-sm font-medium shadow-lg z-50"
    :class="{
      'bg-yellow-50 text-yellow-800 border border-yellow-200': status === 'connecting',
      'bg-orange-50 text-orange-800 border border-orange-200': status === 'disconnected'
    }"
  >
    <div class="flex items-center gap-2">
      <span class="relative flex h-2 w-2">
        <span
          class="animate-ping absolute inline-flex h-full w-full rounded-full opacity-75"
          :class="{
            'bg-yellow-400': status === 'connecting',
            'bg-orange-400': status === 'disconnected'
          }"
        />
        <span
          class="relative inline-flex rounded-full h-2 w-2"
          :class="{
            'bg-yellow-500': status === 'connecting',
            'bg-orange-500': status === 'disconnected'
          }"
        />
      </span>
      <span v-if="status === 'connecting'">Connecting...</span>
      <span v-else-if="status === 'disconnected'">Reconnecting to live updates...</span>
    </div>
  </div>
</template>

<script setup lang="ts">
import type { ConnectionStatus } from '~/composables/useRealtimeStatus'

defineProps<{
  status: ConnectionStatus
}>()
</script>
```

Key differences from staff version:
- Centered horizontally (mobile-friendly)
- Includes animated ping indicator for visual feedback
- Customer-friendly messaging ("live updates" instead of technical terms)
- Softer color scheme with borders
  </action>
  <verify>
Component renders correctly with different status values. Manual test: import in a test page, pass different status values.
  </verify>
  <done>ConnectionStatus.vue exists in customer app, accepts status prop, shows customer-friendly messages.</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. TypeScript verification:
   ```bash
   cd customer && pnpm typecheck
   ```
   Expected: No errors

2. Files exist:
   - customer/app/composables/useRealtimeStatus.ts
   - customer/app/components/ConnectionStatus.vue

3. Composable exports correct interface:
   - useRealtimeStatus accepts requestId string
   - Returns { status, subscribe, unsubscribe }
   - subscribe accepts callback with payload
</verification>

<success_criteria>
1. useRealtimeStatus composable filters by request ID
2. DELETE events are properly filtered in callback (workaround for Supabase limitation)
3. ConnectionStatus component is mobile-friendly (centered, visible on small screens)
4. All files pass TypeScript compilation
5. Type exports are available for consumers
</success_criteria>

<output>
After completion, create `.planning/phases/08-real-time-infrastructure/08-02-SUMMARY.md`
</output>
